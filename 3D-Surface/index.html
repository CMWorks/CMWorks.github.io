<!DOCTYPE html>
<html lang="en">
	<head>
		<title>3D Surface</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				background-color: #FFFFFF;
				color: #202020;
			}
			a {
				color: #080;
			}
			.modal {
			    display: none; /* Hidden by default */
			    position: fixed; /* Stay in place */
			    z-index: 1; /* Sit on top */
			    padding-top: 100px; /* Location of the box */
			    left: 0;
			    top: 0;
			    width: 100%; /* Full width */
			    height: 100%; /* Full height */
			    overflow: auto; /* Enable scroll if needed */
			    background-color: rgb(0,0,0); /* Fallback color */
			    background-color: rgba(0,0,0,0.5); /* Black w/ opacity */
			}

			/* Caption of Modal Image */
			#caption {
			    margin: auto;
			    display: block;
			    width: 80%;
			    max-width: 700px;
			    text-align: center;
			    color: #ccc;
			    padding: 10px 0;
			    height: 150px;
			}

			.loader {
				margin-left: auto;
				margin-right: auto;
			  border: 16px solid #f3f3f3; /* Light grey */
			  border-top: 16px solid #3498db; /* Blue */
			  border-radius: 50%;
			  width: 120px;
			  height: 120px;
			  animation: spin 2s linear infinite;
			}
			/* Safari */
			@-webkit-keyframes spin {
			  0% { -webkit-transform: rotate(0deg); }
			  100% { -webkit-transform: rotate(360deg); }
			}
			@keyframes spin {
			  0% { transform: rotate(0deg); }
			  100% { transform: rotate(360deg); }
			}

			canvas {
    		display: block; /* fix necessary to remove space at bottom of canvas */
			}

		</style>
		<script = src='https://cmworks.github.io/3D-Surface/build/dat.gui.min.js'></script>
		<script = src='https://cmworks.github.io/3D-Surface/build/math.min.js'></script>
		<script = src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML.js'></script>
		<script = src='https://cmworks.github.io/3D-Surface/build/three.min.js'></script>
		<script = src='https://cmworks.github.io/3D-Surface/build/OrbitControls.js'></script>
		<script = src='https://cmworks.github.io/3D-Surface/build/stats.min.js'></script>
	</head>
	<body>

		<div id="myModal" class="modal">
			<div class="loader"></div>
			<div id="caption"></div>
    </div>
		<div id="pretty"></div>
		<script>
			// (x,z,-y)
			var container, stats, fn;
			var camera, scene, renderer;
			var plane, solidMesh;
			var planeMat = new THREE.MeshStandardMaterial({ vertexColors: THREE.VertexColors, side: THREE.DoubleSide });
			var solidMaterial = new THREE.MeshPhongMaterial( {
				color: 0xaaaaaa, flatShading: true,
				side: THREE.DoubleSide,
			} );
			var lineMat = new THREE.LineBasicMaterial( { color: 0x0000ff } );
			var gridMat = new THREE.LineBasicMaterial( { color: 0xA9A9A9 } );
			var max = 0, min = 0;
			var xOff = 10, yOff = 16;
			var width = window.innerWidth-xOff, height = window.innerHeight-yOff;
			var light;
			var colorRange = 240; // 240 for blue to red
			var texture = 0;
			var threeColors = []
			var parsedFunction, parsedWFunction;
			var compiledFunction, compiledWFunction;
			var isImplicit = false;
			var isVector = false;
			var params = {
				// Main
				function: "z=sin(x)+sin(y)",
				texture: changeTexture,
				color: "#000000",
				rRange: "[-5,5] × [-5,5] × [-5,5]",
				resolution: 50,
				contourPlot: false,
				update: update,
				// Tangent
				coordIn: "0,0,0",
				tanOut: "",
				showC1C2: false,
				tangents: false,
				Clear: function(){tanPlane.visible = false;circle.visible = false;},
				// Integral
				n: 2,
				method: "",
				approximate: false,
				volume: "0",
				absVolume: "0",
				average: "0",
				upDT: function(){if (params.approximate){clearIntegralApprox(); drawIntegralApprox();}},
				toInfinit: function(){infinitIntegralApprox()},
				// Fields
				vectorEq: "<y^2-y,x^2-y>",//"<y^2-z,x^2-y,z^2-x>",
				isGradient: false,
				vectorScaling: false,
				doVectorField: false,
				vectorUpdate: function(){clearVectors();if (params.doVectorField) {drawVectors();}},
			};

			//grid
			var xaxis, yaxis, zaxis;
			var xMin, xMax, yMin, yMax, zMin = -5, zMax=5;
			var planeWidth, planeHeight;

			// Latex output
			let options = {parenthesis: 'keep', implicit: 'hide'};
			const pretty = document.getElementById('pretty');
			let parenthesis = 'keep';
			let implicit = 'hide';
			pretty.innerHTML = '$$' + math.parse(params.function).toTex({parenthesis: parenthesis}) + '$$';
			pretty.style.position = 'absolute';
			pretty.style.top = 0 + 'px';
			pretty.style.left = 100 + 'px';

			//intersections
			//Note: b = pointZ, c = pointY, z = -f(a,b)
			var raycaster, mouse = { x : 0, y : 0 };
			var circle;

			//tangents
			var tanLineX, tanLineY, tanPlane;
			var tanFunction;
			var tanFolder;
			var showLines;
			var C1, C2;
			var r = 2;
			var d = new Date();
			//Volume
			var intFolder;
			// var subBoxs = [];
			var boxFieldPos;
			var boxFieldNeg;
			var subBoxsPosMaterial, subBoxsNegMaterial;
			var volume;

			//Contour Plot
			var levels = [];

			//vector and gradient field
			var fieldFolder;
			var arrows = [];

			function update(){
				showLoadingScreen(true);
				setTimeout(run,25);
				function run(){
					min = 0;
					max = 0;
					var aR = params.rRange;
					var xR = aR.substring(aR.indexOf("["),aR.indexOf("]")+1);
					aR = aR.substring(aR.indexOf("]")+1)
					var yR = aR.substring(aR.indexOf("["),aR.indexOf("]")+1);
					aR = aR.substring(aR.indexOf("]")+1)
					var zR = aR.substring(aR.indexOf("["),aR.indexOf("]")+1);
					xMin = math.evaluate(xR.substring(xR.indexOf("[")+1,xR.indexOf(",")).split("ln").join("log"))
				  xMax = math.evaluate(xR.substring(xR.indexOf(",")+1,xR.indexOf("]")).split("ln").join("log"))
					yMin = math.evaluate(yR.substring(yR.indexOf("[")+1,yR.indexOf(",")).split("ln").join("log"))
				  yMax = math.evaluate(yR.substring(yR.indexOf(",")+1,yR.indexOf("]")).split("ln").join("log"))
					zMin = math.evaluate(zR.substring(zR.indexOf("[")+1,zR.indexOf(",")).split("ln").join("log"))
				  zMax = math.evaluate(zR.substring(zR.indexOf(",")+1,zR.indexOf("]")).split("ln").join("log"))
					planeWidth = xMax - xMin;
					planeHeight = yMax - yMin;
					scene.remove(plane);
					scene.remove(solidMesh);
					for (var i = 0; i < levels.length; i++) {
						scene.remove(levels[i]);
					}
					tanPlane.visible = false;circle.visible = false;
					var fun = params.function.split("ln").join("log");
					updateEquationType(fun);
					//scene.remove(zaxis);
					if (!params.contourPlot && !params.doVectorField) {
						//scene.add(zaxis)
					}
					if (params.contourPlot) {
						params.approximate = false;intFolder.updateDisplay();
						lowZ = zMin;
						up = map(params.resolution,1,500,.5,.01);
						for (var c = zMin; c < zMax; c+=up) {
							var cc = colorRange-Math.round(map(c, lowZ, zMax, 0, colorRange));
							num = levelCurve(c,threeColors[cc]);
							if (num == 0) {
								lowZ+=up;
							}
						}
					}else if(params.function != ""){
						if (isImplicit) {
							solidPlot(0,map(params.resolution,1,500,5,100));
						}else {
							plane = new THREE.Mesh( new THREE.PlaneGeometry(planeWidth,planeHeight,params.resolution,params.resolution), planeMat );
							plane.rotation.x = (-Math.PI/2);
							scene.add(plane);
							for (var i = 0; i < plane.geometry.faces.length; i++) {
								plane.geometry.faces[i].vertexColors[0] = new THREE.Color( 0x000000 );
								plane.geometry.faces[i].vertexColors[1] = new THREE.Color( 0x000000 );
								plane.geometry.faces[i].vertexColors[2] = new THREE.Color( 0x000000 );
							}
							updatePlane();
						}
					}
					CLineHide();
					clearIntegralApprox();
					showLines.__checkbox.checked = false;
					showLines.setValue(false);
					if (params.approximate) {
						drawIntegralApprox();
					}
					showLoadingScreen(false);
				}
			}

			function updateEquationType(eq){
				var sides = eq.split("=");
				var leftSide = sides[0];
				var rightSide = sides[1];
				//z=... or f(x,y)=... -- surface equation
				if (leftSide == "z" || leftSide == "f(x,y)") {
					isImplicit = false;
					parsedFunction = math.parse(rightSide);
					compiledFunction = math.compile(rightSide);
				}else {	// implicit function
					isImplicit = true;
					w = leftSide+"-("+rightSide+")";
					parsedWFunction = math.parse(w);
					compiledWFunction = math.compile(w);
				}
			}

			function changeTexture(){
				texture+=1;
				if (texture>3) {
					texture = 0;
				}
				colorPlane();
			}

			 function f(a,b){
				 try {
					 return compiledFunction.evaluate({ x: a, y: b })
				 } catch (e) {
					return NaN;
				 }
			 }
			 function wFunc(a,b,c){
				 // return Math.pow(x*x+y*y*9/4+z*z-1,3)-x*x*z*z*z-9/200*y*y*z*z*z
				 // return Math.sin(x*x+y*y+z*z-64);
				 // return a*a+b*b+c*c-16;
				 try {
					 return compiledWFunction.evaluate({ x: a, y: b, z: c })
				 } catch (e) {
					return NaN;
				 }
			 }

			 function calculateTan(a,b,c){
				 if (isImplicit) {
					 let dx = math.derivative(parsedWFunction, "x").evaluate({x: a, y: b, z: c});
					 let dy = math.derivative(parsedWFunction, "y").evaluate({x: a, y: b, z: c});
					 let dz = math.derivative(parsedWFunction, "z").evaluate({x: a, y: b, z: c});
					 let ww = math.round((dx*a+dy*b+dz*c)/dz,r);
					 var d1 = math.round(dx/dz,r);
					 var d2 = math.round(dy/dz,r);
					 tanFunction = math.format(math.simplify(math.parse(ww+"-"+d1+"*x-"+d2+"*y"), {}, {exactFractions: false}));
					 tanFunction = tanFunction.split(" ").join("");
					 tanFunction = tanFunction.split("+-").join("-");
					 tanFunction = tanFunction.split("-+").join("-");
				 }else {
					 c = parsedFunction.evaluate({x: a, y: b});
					 let dx = math.derivative(parsedFunction, "x").evaluate({x: a, y: b});
					 let dy = math.derivative(parsedFunction, "y").evaluate({x: a, y: b});
					 let cc = math.round(c-dx*a-dy*b,r);
					 tanFunction = math.format(math.simplify(math.parse(math.round(dx,r)+"*x+"+math.round(dy,r)+"*y+"+cc), {}, {exactFractions: false}));
					 tanFunction = tanFunction.split(" ").join("");
					 tanFunction = tanFunction.split("+-").join("-");
					 tanFunction = tanFunction.split("-+").join("-");
					 //tanFunction = math.format(math.simplify(math.parse(tanFunction)));
				 }
				 											// postion vector of the tangental point
				 return [tanFunction, new THREE.Vector3(a,c,b)];
			 }

			 function CLine(a,b){
				 let res = 5, points = [];
				 scene.remove(C1);scene.remove(C2);
				 if (isImplicit) {

				 }else {
					 for (var i = xMin; i <=xMax; i+=1/res) {
						 points.push( new THREE.Vector3(i,parsedFunction.evaluate({ x: i, y: b }), -b) );
					 }
					 var geometry = new THREE.BufferGeometry().setFromPoints( points );
					 C1 = new THREE.Line( geometry, lineMat );

					 points = [];
					 for (var i = yMin; i <= yMax; i+=1/res) {
						 points.push( new THREE.Vector3(a,parsedFunction.evaluate({ x: a, y: i }), -i) );
					 }
					 geometry = new THREE.BufferGeometry().setFromPoints( points );
					 C2 = new THREE.Line( geometry, lineMat );

					 scene.add(C1);scene.add(C2);
				 }
				 C1.visible = plane.material.wireframe; C2.visible = plane.material.wireframe;
			 }

			 function CLineHide(){
				 scene.remove(C1);scene.remove(C2);
				var material = new THREE.LineBasicMaterial( { color: 0x0000ff } );
 				var points = [];
 				points.push( new THREE.Vector3( 0, 0, 0 ) );
 				points.push( new THREE.Vector3( 0, 0, 0 ) );
 				points.push( new THREE.Vector3( 0, 0, 0 ) );
 				var geometry = new THREE.BufferGeometry().setFromPoints( points );
 				C1 = new THREE.Line( geometry, material );C2 = new THREE.Line( geometry, material );
 				C1.visible = false; C2.visible = false;
			 }

			 /**
				* Re-maps a number from one range to another.
				* @method map
				* @param  {Number} value  the incoming value to be converted
				* @param  {Number} start1 lower bound of the value's current range
				* @param  {Number} stop1  upper bound of the value's current range
				* @param  {Number} start2 lower bound of the value's target range
				* @param  {Number} stop2  upper bound of the value's target range
				* @param  {Boolean} [withinBounds] constrain the value to the newly mapped range
				* @return {Number}        remapped number
				*
				*/
			function map(n, start1, stop1, start2, stop2){
				return (n - start1) / (stop1 - start1) * (stop2 - start2) + start2;
			}

			function hslToRgb(h, s, l){
				var r, g, b;

				if(s == 0){
						r = g = b = l; // achromatic
				}else{
						var hue2rgb = function hue2rgb(p, q, t){
								if(t < 0) t += 1;
								if(t > 1) t -= 1;
								if(t < 1/6) return p + (q - p) * 6 * t;
								if(t < 1/2) return q;
								if(t < 2/3) return p + (q - p) * (2/3 - t) * 6;
								return p;
						}

						var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
						var p = 2 * l - q;
						r = hue2rgb(p, q, h + 1/3);
						g = hue2rgb(p, q, h);
						b = hue2rgb(p, q, h - 1/3);
				}

				return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
			}

			function updatePlane(){
				// total vertices for a resolution of n is n^2+2*n+1
				//sets vertices to points based on bounded range R

				var last = d.getTime();
				var n = 0;
				var dx = planeWidth/params.resolution;
				var dy = planeHeight/params.resolution;
				for (var y = yMin; y <= yMax+dy/2; y+=dy) {	//offseted by dy to acount for rounding error
					for (var x = xMin; x <= xMax+dx/2; x+=dx) {
						if (n < params.resolution*params.resolution+2*params.resolution+1) {
							plane.geometry.vertices[n].x = x;
							plane.geometry.vertices[n].y = y;
							let newZ = f(x, y);
							plane.geometry.vertices[n].z = newZ;
							if (isFinite(newZ)) {
								if (newZ > max) {
									max = newZ;
								}if (newZ < min) {
									min = newZ;
								}
							}
							n++;
						}else {
							break;
						}
					}
				}
				/*
				// sets vertices to actual values
				for (var i = 0; i < plane.geometry.vertices.length; i++) {
					let newZ = f(plane.geometry.vertices[i].x, plane.geometry.vertices[i].y);
					plane.geometry.vertices[i].z = newZ;
					if (isFinite(newZ)) {
						if (newZ > max) {
							max = newZ;
						}if (newZ < min) {
							min = newZ;
						}
					}
				}*/
				colorPlane();
				plane.geometry.verticesNeedUpdate=true;
			}

			function colorPlane(){
				/*for (var i = 0; i < plane.geometry.faces.length; i++) {
					plane.geometry.faces[i].vertexColors[0].setHex(0x000000)
					plane.geometry.faces[i].vertexColors[1].setHex(0x000000)
					plane.geometry.faces[i].vertexColors[2].setHex(0x000000)
				}*/
				var col1 = new THREE.Color(params.color)
				var col2 = new THREE.Color()
				for (var i = 0; i < plane.geometry.faces.length; i++) {
					plane.geometry.faces[i].vertexColors[0].setHex(0x000000)
					plane.geometry.faces[i].vertexColors[1].setHex(0x000000)
					plane.geometry.faces[i].vertexColors[2].setHex(0x000000)
					var a = plane.geometry.vertices[plane.geometry.faces[i].a].z;
					var b = plane.geometry.vertices[plane.geometry.faces[i].b].z;
					var c = plane.geometry.vertices[plane.geometry.faces[i].c].z;
					if (texture == 0) { // colored lines
						plane.geometry.faces[i].vertexColors[0].add(col1);
						plane.geometry.faces[i].vertexColors[1].add(col2);
						plane.geometry.faces[i].vertexColors[2].add(col1);
						var ca = colorRange-Math.round(map(a, min, max, 0, colorRange));
						var cb = colorRange-Math.round(map(b, min, max, 0, colorRange));
						var cc = colorRange-Math.round(map(c, min, max, 0, colorRange));
						if (isFinite(ca)) {
							plane.geometry.faces[i].vertexColors[0].add(threeColors[ca])
							//plane.geometry.faces[i].vertexColors[0].add(new THREE.Color("hsl("+ca+",75%,40%)"));
						}if (isFinite(cb)) {
							plane.geometry.faces[i].vertexColors[1].add(threeColors[cb])
							// plane.geometry.faces[i].vertexColors[1].add(new THREE.Color("hsl("+cb+",75%,40%)"));
						}if (isFinite(cc)) {
							plane.geometry.faces[i].vertexColors[2].add(threeColors[cc])
							// plane.geometry.faces[i].vertexColors[2].add(new THREE.Color("hsl("+cc+",75%,40%)"));
						}
					}else if(texture == 1){ // blue map
						var cb = Math.round(map(b, min, max, 00, 255));
						var cc = Math.round(map(c, min, max, 0, 255));
						if (isFinite(ca)) {
							plane.geometry.faces[i].vertexColors[0].setHex(0x000000);
						}if (isFinite(cb)) {
							plane.geometry.faces[i].vertexColors[1].setHex(cb);
						}if (isFinite(cc)) {
							plane.geometry.faces[i].vertexColors[2].setHex(cc);
						}
					}else if(texture == 2){ // white lines
						var ca = colorRange-Math.round(map(a, min, max, 0, colorRange));
						var cb = colorRange-Math.round(map(b, min, max, 0, colorRange));
						var cc = colorRange-Math.round(map(c, min, max, 0, colorRange));
						var col = hslToRgb(ca, .75, .4);
						if (isFinite(ca)) {
							plane.geometry.faces[i].vertexColors[0].setRGB(col[0],col[1],col[2]);
						}if (isFinite(cb)) {
							col = hslToRgb(cb, .75, .4);
							plane.geometry.faces[i].vertexColors[1].setHSL(col[0],col[1],col[2]);
						}if (isFinite(cc)) {
							col = hslToRgb(cc, .75, .4);
							plane.geometry.faces[i].vertexColors[2].setHSL(col[0],col[1],col[2]);
						}
					}else if (texture == 3) { // green layerd map
						var ca = Math.round(map(a, min, max, 1000000, colorRange));
						var cb = Math.round(map(b, min, max, 1000000, colorRange));
						var cc = Math.round(map(c, min, max, 1000000, colorRange));
						//console.log(ca+", "+cb+", "+cc);
						if (isFinite(ca)) {
							plane.geometry.faces[i].vertexColors[0].setHex(ca);
						}if (isFinite(cb)) {
							plane.geometry.faces[i].vertexColors[1].setHex(cb);
						}if (isFinite(cc)) {
							plane.geometry.faces[i].vertexColors[2].setHex(cc);
						}
					}
				}
				plane.geometry.colorsNeedUpdate = true;
			}

			function showLoadingScreen(show){
				if (show) {
					document.getElementById("myModal").style.display = "block";
				}else {
					document.getElementById("myModal").style.display = "none";
				}
			}

			init();
			animate();

			function init() {

				container = document.createElement( 'div' );
				document.body.appendChild( container );

				// scene

				scene = new THREE.Scene();
				scene.background = new THREE.Color( 0xFFFFFF );

				// camera

				camera = new THREE.PerspectiveCamera( 30, width / height, 1, 10000 );

				// lights

				scene.add( new THREE.AmbientLight( 0x666666 ) );

				var light = new THREE.DirectionalLight( 0x666666, 1 );
				light.position.set( 50, 200, 100 );
				light.position.multiplyScalar( 1.3 );

				light.castShadow = true;

				light.shadow.mapSize.width = 1024;
				light.shadow.mapSize.height = 1024;

				var d = 300;

				light.shadow.camera.left = - d;
				light.shadow.camera.right = d;
				light.shadow.camera.top = d;
				light.shadow.camera.bottom = - d;

				light.shadow.camera.far = 1000;

				scene.add( light );

				var light2 = new THREE.DirectionalLight( 0x666666, 1 );
				light2.position.set( 50, 200, 100 );
				light2.position.multiplyScalar( -1.3 );

				light2.castShadow = true;

				light2.shadow.mapSize.width = 1024;
				light2.shadow.mapSize.height = 1024;

				var d = 300;

				light2.shadow.camera.left = - d;
				light2.shadow.camera.right = d;
				light2.shadow.camera.top = d;
				light2.shadow.camera.bottom = - d;

				light2.shadow.camera.far = 1000;

				scene.add( light2 );

				// sets up threeColors
				for (var i = 0; i <= 240; i++) {
					threeColors[i] = new THREE.Color("hsl("+i+",75%,40%)")
				}

				// adds plane
				plane = new THREE.Mesh( new THREE.PlaneGeometry(10,10,10,10), planeMat );
				plane.rotation.x = (-Math.PI/2);
				scene.add(plane);
				for (var i = 0; i < plane.geometry.faces.length; i++) {
					plane.geometry.faces[i].vertexColors[0] = new THREE.Color( 0x000000 );
					plane.geometry.faces[i].vertexColors[1] = new THREE.Color( 0x000000 );
					plane.geometry.faces[i].vertexColors[2] = new THREE.Color( 0x000000 );
				}
				camera.position.set( 10, 5, 15 );
				camera.lookAt(0,0,10);

				//adds tangent plane
				tanPlane = new THREE.Mesh( new THREE.PlaneGeometry(10,10), planeMat );
				tanPlane.visible = false;
				tanPlane.rotateX(math.pi/2);
				scene.add(tanPlane);

				//adds C1 and C2
				var material = new THREE.LineBasicMaterial( { color: 0x0000ff } );
				var points = [];
				points.push( new THREE.Vector3( 0, 0, 0 ) );
				points.push( new THREE.Vector3( 0, 0, 0 ) );
				points.push( new THREE.Vector3( 0, 0, 0 ) );
				var geometry = new THREE.BufferGeometry().setFromPoints( points );
				C1 = new THREE.Line( geometry, material );C2 = new THREE.Line( geometry, material );
				C1.visible = false; C2.visible = false;

				//axis
				var s = 10;
				xaxis = new THREE.Mesh(new THREE.BoxGeometry( s,.025,.025 ), new THREE.MeshBasicMaterial( {color: 0xff0000} ));
				//zaxis = new THREE.Mesh(new THREE.BoxGeometry( .025,s,.025 ), new THREE.MeshBasicMaterial( {color: 0x0000ff} ));
				yaxis = new THREE.Mesh(new THREE.BoxGeometry( .025,.025,s ), new THREE.MeshBasicMaterial( {color: 0x00ff00} ));
				xaxis.geometry.translate(s/2,0,0)
			//	zaxis.geometry.translate(0,s/2,0)
				yaxis.geometry.translate(0,0,-s/2)
				scene.add(xaxis);
				scene.add(yaxis);
				//scene.add(zaxis);
				document.getElementById("caption").innerHTML = "Loading..."

				//grid
				var points = [];
				for (var y = -10; y <= 10; y++) {
					for (var x = -10; x <= 10; x++) {
						if (x!=10) {
							points.push(new THREE.Vector3(x,0,-y))
							points.push(new THREE.Vector3(x+1,0,-y))
						}if (y!=10) {
							points.push(new THREE.Vector3(x,0,-y))
							points.push(new THREE.Vector3(x,0,-y-1))
						}
					}
				}
				var geometry = new THREE.BufferGeometry().setFromPoints( points );
				gline = new THREE.LineSegments( geometry, gridMat );
				scene.add(gline)


				//subBoxes material
				subBoxsPosMaterial = new THREE.MeshPhongMaterial( {color: 0x00ff00, side: THREE.DoubleSide, transparent: true, opacity: .5} );
				subBoxsNegMaterial = new THREE.MeshPhongMaterial( {color: 0x00fff0, side: THREE.DoubleSide, transparent: true, opacity: .5} );


				// renderer

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( width, height );

				container.appendChild( renderer.domElement );

				renderer.outputEncoding = THREE.sRGBEncoding;

				renderer.shadowMap.enabled = true;

				// intersections
				raycaster = new THREE.Raycaster();
    		renderer.domElement.addEventListener( 'mousemove', updateMouse, false );
				circle = new THREE.Mesh(new THREE.SphereGeometry( .1, 32, 32 ), new THREE.MeshBasicMaterial( {color: 0xffff00} ));
				circle.visible = false;
				scene.add(circle);

				// controls
				var controls = new THREE.OrbitControls( camera, renderer.domElement );
				//controls.maxPolarAngle = Math.PI * 0.5;
				controls.minDistance = 1;
				controls.maxDistance = 5000;
				// call this only in static scenes (i.e., if there is no animation loop)
				controls.addEventListener( 'change', render );

				// performance monitor

				stats = new Stats();
				container.appendChild( stats.dom );

				//event listener
				window.addEventListener( 'resize', onWindowResize, false );

				// gui
				var gui = new dat.GUI();
				fn = gui.add( params, 'function' ).name("Equation:").onFinishChange(function(){
					update();
				});
				gui.add( params, 'texture' );
				gui.addColor(params, 'color').onChange(function(value) {
					colorPlane();
				});
				gui.add( params, 'rRange' ).name("R = ").onFinishChange(function(){
			    update();
			  });
				gui.add( params, 'resolution' ).min(1).max(500).step(1);
				gui.add( params, 'contourPlot').name("Contour Plot").onFinishChange(function(){
					update();
				});
				gui.add( params, 'update' );

				//tanFolder
				tanFolder = gui.addFolder("Tangent");
				coordIn = tanFolder.add(params, "coordIn").name("Coordinate x,y,z").onFinishChange(function(){
					if (isImplicit && params.coordIn.indexOf(',') != params.coordIn.lastIndexOf(',')) {
						var a = math.parse(params.coordIn.substring(0,params.coordIn.indexOf(',')).split("ln").join("log")).evaluate();
						var b = math.parse(params.coordIn.substring(params.coordIn.indexOf(',')+1,params.coordIn.lastIndexOf(",")).split("ln").join("log")).evaluate();
						var c = math.parse(params.coordIn.substring(params.coordIn.lastIndexOf(',')+1).split("ln").join("log")).evaluate();
					}else {
						var a = math.parse(params.coordIn.substring(0,params.coordIn.indexOf(',')).split("ln").join("log")).evaluate();
						if (params.coordIn.indexOf(',') == params.coordIn.lastIndexOf(',')) {
							var b = math.parse(params.coordIn.substring(params.coordIn.indexOf(',')+1).split("ln").join("log")).evaluate();
						}else {
							var b = math.parse(params.coordIn.substring(params.coordIn.indexOf(',')+1,params.coordIn.lastIndexOf(",")).split("ln").join("log")).evaluate();
						}
						var c = wFunc(a,b,0);
					}
					drawTangents(a,b,c);
				});
				tanOut = tanFolder.add(params, "tanOut").name("z=");
				document.getElementsByTagName("input")[6].disabled = true;
				showLines = tanFolder.add( params, 'showC1C2').name("Show C1 & C2").onFinishChange(function(){
					plane.material.wireframe = params.showC1C2;
					C1.visible = plane.material.wireframe;
 				 	C2.visible = plane.material.wireframe;
				});
				tanFolder.add( params, 'tangents').name("Auto Display");
				tanFolder.add(params, "Clear");

				//Integral folder
				intFolder = gui.addFolder("Integral");
				intFolder.add(params, "n").min(2).max(100).step(1);
				intFolder.add(params, "method",["Bottem Left","Top Right","Midpoint"]).name("Method");
				intFolder.add(params, "approximate").name("Approx Volume").onFinishChange(function(){
					if (params.approximate) {
						drawIntegralApprox();
					}else {
						clearIntegralApprox();
					}
				});
				intFolder.add(params, "volume").name("Volume: ");
				document.getElementsByTagName("input")[11].disabled = true;
				intFolder.add(params, "absVolume").name("Abs Volume: ");
				document.getElementsByTagName("input")[12].disabled = true;
				intFolder.add(params, "average").name("Average Value: ");
				document.getElementsByTagName("input")[13].disabled = true;

				intFolder.add(params,"upDT").name("Update Volume");
				intFolder.add(params,"toInfinit").name("do n,m = 2000");

				fieldFolder = gui.addFolder("Fields");
				fieldFolder.add(params, "vectorEq").name("v = ").onFinishChange(function(){
					clearVectors();
					if (params.doVectorField) {
						drawVectors();
					}
				});
				fieldFolder.add(params, "isGradient").name("Is Gradient?").onFinishChange(function(){
					clearVectors();
					if (params.doVectorField) {
						drawVectors();
					}
				});
				fieldFolder.add(params, "vectorScaling").name("Uniform Scaling?").onFinishChange(function(){
					clearVectors();
					if (params.doVectorField) {
						drawVectors();
					}
				});
				fieldFolder.add(params, "doVectorField").name("Display Field").onFinishChange(function(){
					clearVectors();
					if (params.doVectorField) {
						drawVectors();
					}
				});
				fieldFolder.add(params, "vectorUpdate").name("Update Field");
				update();
			}

			function onWindowResize() {

				camera.aspect = (window.innerWidth-xOff) / (window.innerHeight-yOff);
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth-xOff, window.innerHeight-yOff );

			}

			function animate() {

				requestAnimationFrame( animate );
				render();
				stats.update();
			}

			function render() {
				print();
				if (params.tangents) {
					raycast();
				}
				// vector = toXYCoords(new THREE.Vector3(1,1,1));
				// text2.style.top = vector.x + 'px';
				// text2.style.left = vector.y + 'px';
				renderer.render( scene, camera );
			}

			function print () {
				let node = null
				let fun = params.function;
				try {
					// parse the expression and simplifies it
					// node = math.simplify(math.parse(fun));
					// fn.setValue(node.toString());

					//regular parse
					node = math.parse(fun);
				}
				catch (err) {}

				try {
					// export the expression to LaTeX
					node = math.parse(node.toString().split("=").join("=="));
					const latex = node ? node.toTex({parenthesis: parenthesis, implicit: implicit}) : ''

					// display and re-render the expression
					const elem = MathJax.Hub.getAllJax('pretty')[0]
					MathJax.Hub.Queue(['Text', elem, latex])
				}
				catch (err) {}
			}

			function updateMouse( e ){
				mouse.x = ( e.clientX / (window.innerWidth-xOff) ) * 2 - 1 - (xOff/window.innerWidth);
				mouse.y = - ( (e.clientY) / (window.innerHeight-yOff) ) * 2 + 1 + (yOff/window.innerHeight);
			}

			function raycast ( ) {
				//1. sets the mouse position with a coordinate system where the center
				//   of the screen is the origin


				//2. set the picking ray from the camera position and mouse coordinates
				raycaster.setFromCamera( mouse, camera );

				//3. compute intersections
				var intersects
				if (isImplicit) {
					intersects = raycaster.intersectObject( solidMesh );
				}else {
					intersects = raycaster.intersectObject( plane );
				}
				if (intersects.length > 0) {
					let a = intersects[0].point.x, b = -intersects[0].point.z, c = intersects[0].point.y;
					drawTangents(a,b,c);
				}

			}

			function drawTangents(a,b,c){
				var v = calculateTan(a,b,c);
				circle.position.set(v[1].x,v[1].y,-v[1].z);
				coordIn.setValue(math.round(a,r)+","+math.round(b,r)+","+math.round(v[1].y,r))
				tanOut.setValue(v[0]);

				//updates tangent plane
				tanPlane.geometry.vertices[0].x = a-1;
				tanPlane.geometry.vertices[0].y = -b+1;
				tanPlane.geometry.vertices[0].z = -math.parse(tanFunction).evaluate({ x: a-1, y: b-1 });

				tanPlane.geometry.vertices[1].x = a+1;
				tanPlane.geometry.vertices[1].y = -b+1;
				tanPlane.geometry.vertices[1].z = -math.parse(tanFunction).evaluate({ x: a+1, y: b-1 });

				tanPlane.geometry.vertices[3].x = a+1;
				tanPlane.geometry.vertices[3].y = -b-1;
				tanPlane.geometry.vertices[3].z = -math.parse(tanFunction).evaluate({ x: a+1, y: b+1 });

				tanPlane.geometry.vertices[2].x = a-1;
				tanPlane.geometry.vertices[2].y = -b-1;
				tanPlane.geometry.vertices[2].z = -math.parse(tanFunction).evaluate({ x: a-1, y: b+1 });

				tanPlane.geometry.verticesNeedUpdate=true;

				tanPlane.visible = true;
				circle.visible = true;
				//updates tangent curves
				CLine(a, b);
			}

			function drawIntegralApprox(){
				subBoxs = [];
				dx = planeWidth/params.n;
				dy = planeHeight/params.n;
				//left point approx
				volume = 0;
				absVol = 0;
				i = 0;
				var volGeoPos = new THREE.BoxGeometry(.01,.01,.01);
				var volGeoNeg = new THREE.BoxGeometry(.01,.01,.01);
				for (var y = yMin; y < yMax; y+=dy) {
					for (var x = xMin; x < xMax; x+=dx) {
						//point (x,z,-y)
						if (params.method == "Bottem Left") {
							var z = f(x,y);
						}else if (params.method == "Top Right") {
							var z = f(x+dx,y+dy);
						}else if (params.method == "Midpoint") {
							var z = f(x+dx/2,y+dy/2);
						}else {
							var z = 0;
						}
						box = new THREE.Mesh(new THREE.BoxGeometry( dx, z ,dy ));
						box.translateX(x)
						box.translateY(z/2)
						box.translateZ(-y)
						box.updateMatrix();
						if (z >=0 ) {
							volGeoPos.merge(box.geometry, box.matrix)
						}else {
							volGeoNeg.merge(box.geometry, box.matrix)
						}
						volume += dx*dy*z;
						absVol += Math.abs(dx*dy*z);
						i++;
					}
				}
				params.volume = ""+math.round(volume,r+2);
				params.absVolume = ""+math.round(absVol,r+2);
				params.average = ""+math.round(volume/(planeWidth*planeHeight),r+2)
				intFolder.updateDisplay();
				planeMat.visible = false;
				boxFieldPos = new THREE.Mesh(volGeoPos, subBoxsPosMaterial)
				boxFieldNeg = new THREE.Mesh(volGeoNeg, subBoxsNegMaterial)
				scene.add(boxFieldPos)
				scene.add(boxFieldNeg)
			}

			function clearIntegralApprox(){
				planeMat.visible = true;
				scene.remove(boxFieldPos)
				scene.remove(boxFieldNeg)
			}

			function infinitIntegralApprox(){
				var longN = 1000;
				dx = planeWidth/longN;
				dy = planeHeight/longN;
				//left point approx
				volume = 0;
				absVol = 0;
				for (var y = yMin; y < yMax; y+=dy) {
					for (var x = xMin; x < xMax; x+=dx) {
						//point (x,z,-y)
						if (params.method == "Bottem Left") {
							var z = f(x,y);
						}else if (params.method == "Top Right") {
							var z = f(x+dx,y+dy);
						}else if (params.method == "Midpoint") {
							var z = f(x+dx/2,y+dy/2);
						}else {
							var z = 0;
						}
						volume += dx*dy*z;
						absVol += Math.abs(dx*dy*z);
					}
				}
				params.volume = ""+math.round(volume,r+2);
				params.absVolume = ""+math.round(absVol,r+2);
				params.average = ""+math.round(volume/(planeWidth*planeHeight),r+2)
				intFolder.updateDisplay();
			}

			function drawVectors(){
				//scene.remove(zaxis);
				minValue = 10000000, maxValue = -1000000000;
				var points = [];
				var colors;
				// color: 'hsl('+size+',75%,50%)';
				parts = params.vectorEq.replace("<","").replace(">","").split(",");
				vectorFun = [];
				gradientFun = [];
				for (var i = 0; i < parts.length; i++) {
					vectorFun[i] = math.parse(parts[i].split("ln").join("log")).compile();
				}
				if (params.isGradient) {
					gradientFun[0] =  math.derivative(parts[0], "x").compile();
					gradientFun[1] =  math.derivative(parts[1], "y").compile();
					if (parts.length == 3) {
						gradientFun[2] =  math.derivative(parts[2], "z").compile();
					}
				}

				if (parts.length == 3) {
					step = map(params.resolution,1,1000,2,.1);
				}else {
					step = map(params.resolution,1,1000,1,.08);
					step = map(Math.sqrt(params.resolution),1,32,1,.05);
				}

				var i = 0;
				//sets up min and max
				if (parts.length == 3) {
					for (var c = zMin; c < zMax; c+=step) {
						for (var b = yMin; b < yMax; b+=step) {
							for (var a = xMin; a < xMax; a+=step) {
								i++;
								if (params.isGradient) {
									var dir = new THREE.Vector3( gradientFun[0].evaluate({x:a, y:b, z:c}), gradientFun[2].evaluate({x:a, y:b, z:c}), -gradientFun[1].evaluate({x:a, y:b, z:c}));
								}else {
									var dir = new THREE.Vector3( vectorFun[0].evaluate({x:a, y:b, z:c}), vectorFun[2].evaluate({x:a, y:b, z:c}), -vectorFun[1].evaluate({x:a, y:b, z:c}));
								}
								len = dir.length();
								if (len > maxValue) {
									maxValue = len;
								}else if (len < minValue) {
									minValue = len;
								}
							}
						}
					}
				}else {
					for (var b = yMin; b < yMax; b+=step) {
						for (var a = xMin; a < xMax; a+=step) {
							i++;
							if (params.isGradient) {
								var dir = new THREE.Vector3( gradientFun[0].evaluate({x:a, y:b}), 0, -gradientFun[1].evaluate({x:a, y:b}));
							}else {
								var dir = new THREE.Vector3( vectorFun[0].evaluate({x:a, y:b}), 0, -vectorFun[1].evaluate({x:a, y:b}));
							}
							len = dir.length();
							if (len > maxValue) {
								maxValue = len;
							}else if (len < minValue) {
								minValue = len;
							}
						}
					}
				}

				var j = 0;
				//Draws Vectors
				if (parts.length == 3) {
					colors = new Float32Array(i*6);
					for (var c = zMin; c < zMax; c+=step) {
						for (var b = yMin; b < yMax; b+=step) {
							for (var a = xMin; a < xMax; a+=step) {
								if (params.isGradient) {
									var dir = new THREE.Vector3( gradientFun[0].evaluate({x:a, y:b, z:c}), gradientFun[2].evaluate({x:a, y:b, z:c}), -gradientFun[1].evaluate({x:a, y:b, z:c}));
								}else {
									var dir = new THREE.Vector3( vectorFun[0].evaluate({x:a, y:b, z:c}), vectorFun[2].evaluate({x:a, y:b, z:c}), -vectorFun[1].evaluate({x:a, y:b, z:c}));
								}
								if (dir.length()!=0) {
									size = map(dir.length(),minValue,maxValue,240,0);
									if (params.vectorScaling) {
										dir.normalize();
									}else {
										dir.setLength(step)
									}
									dirSmall = new THREE.Vector3();
									dirSmall.copy(dir);
									dirSmall.setLength(dir.length()/10)
									var hsl = math.round(size,3);
									if (!isFinite(hsl)) {
										hsl = 0;
									}
									var color = new THREE.Color('hsl('+hsl+',75%,50%)');
									points.push( new THREE.Vector3(a, c, -b) )
									points.push( new THREE.Vector3(a+dir.x, c+dir.y, dir.z-b) )
									// points.push( new THREE.Vector3(a+dir.x, c+dir.z, dir.y-b) )
									// points.push( new THREE.Vector3(a+dir.x+dirSmall.x, c+dir.z+dirSmall.z, dir.y+dirSmall.y-b) )
									colors[j] = color.r;
									colors[j+1] = color.g;
									colors[j+2] = color.b;

									colors[j+3] = color.r;
									colors[j+4] = color.g;
									colors[j+5] = color.b;

									// colors[j+6] = 0;
									// colors[j+7] = 0;
									// colors[j+8] = 0;
									//
									// colors[j+9] = 0;
									// colors[j+10] = 0;
									// colors[j+11] = 0;
									j+=6
								}
							}
						}
					}
				}
				else {
					colors = new Float32Array(i*12);
					for (var b = yMin; b < yMax; b+=step) {
						for (var a = xMin; a < xMax; a+=step) {
							if (params.isGradient) {
								var dir = new THREE.Vector3( gradientFun[0].evaluate({x:a, y:b}), 0, -gradientFun[1].evaluate({x:a, y:b}));
							}else {
								var dir = new THREE.Vector3( vectorFun[0].evaluate({x:a, y:b}), 0, -vectorFun[1].evaluate({x:a, y:b}));
							}
							if (dir.length()!=0) {
								size = map(dir.length(),minValue,maxValue,240,0);
								if (params.vectorScaling) {
									dir.setLength(step)
								}else {
									dir.setLength(  Math.min(Math.max(map(size,240,0,((xMax-xMin)+(yMax-yMin))/400,((xMax-xMin)+(yMax-yMin))/100),step/2),step)  )
								}
								dirSmall = new THREE.Vector3();
								dirSmall.copy(dir);
								dirSmall.setLength(dir.length()/10)
								var hsl = math.round(size,3);
								if (!isFinite(hsl)) {
									hsl = 0;
								}
								var color = new THREE.Color('hsl('+hsl+',75%,50%)');
								points.push( new THREE.Vector3(a, 0, -b) )
								points.push( new THREE.Vector3(a+dir.x, 0, dir.z-b) )
								points.push( new THREE.Vector3(a+dir.x, 0, dir.z-b) )
								points.push( new THREE.Vector3(a+dir.x+dirSmall.x, 0, dir.z+dirSmall.z-b) )
								colors[j] = color.r;
								colors[j+1] = color.g;
								colors[j+2] = color.b;

								colors[j+3] = color.r;
								colors[j+4] = color.g;
								colors[j+5] = color.b;

								colors[j+6] = 0;
								colors[j+7] = 0;
								colors[j+8] = 0;

								colors[j+9] = 0;
								colors[j+10] = 0;
								colors[j+11] = 0;
								j+=12
							}
						}
					}
				}
				var material = new THREE.LineBasicMaterial( {linewidth: 5, vertexColors: true} );
				var geometry = new THREE.BufferGeometry().setFromPoints( points );
				geometry.setAttribute( 'color', new THREE.BufferAttribute( colors, 3 ) );
				line = new THREE.LineSegments( geometry, material );
				arrows.push(line);
				scene.add(line);
			}

			function clearVectors(){
				for (var i = 0; i < arrows.length; i++) {
					scene.remove(arrows[i]);
				}
				arrows = [];
				if (!params.contourPlot && !params.doVectorField) {
					//scene.add(zaxis)
				}
			}




			function levelCurve(c, rgb){
				var vertecies = marchingSquares( c, 60 );
				var line;

				var points = []
 				for (var i = 0; i < vertecies.length; i++) {
 					points.push( new THREE.Vector3(vertecies[i][2], vertecies[i][1], -vertecies[i][0]) )
 				}
				var material = new THREE.LineBasicMaterial( {linewidth: 5, color: rgb,  } );
				var geometry = new THREE.BufferGeometry().setFromPoints( points );
				line = new THREE.LineSegments( geometry, material );
				levels.push(line)
				scene.add(line)
				return points.length;
			}

			function solidPlot(c,res){
				var geometry = new THREE.BufferGeometry();
				triangleVertex = marchingCubes( c,res );
				var positions = new Float32Array(triangleVertex.length *3 *3);
				var normals = new Float32Array(triangleVertex.length *3 *3);
				var colors = new Float32Array(triangleVertex.length *3 *3);
				var color = new THREE.Color();
				var pA = new THREE.Vector3();
				var pB = new THREE.Vector3();
				var pC = new THREE.Vector3();

				var cb = new THREE.Vector3();
				var ab = new THREE.Vector3();

				//computes normals and colors
				var j = 0;
				for (var i = 0; i < triangleVertex.length; i+=3) {
					// Positions
					positions[j] = triangleVertex[i][0];
					positions[j+1] = triangleVertex[i][2];
					positions[j+2] = -triangleVertex[i][1];

					positions[j+3] = triangleVertex[i+1][0];
					positions[j+4] = triangleVertex[i+1][2];
					positions[j+5] = -triangleVertex[i+1][1];

					positions[j+6] = triangleVertex[i+2][0];
					positions[j+7] = triangleVertex[i+2][2];
					positions[j+8] = -triangleVertex[i+2][1];

					// Normal faces
					pA.set(triangleVertex[i][0],triangleVertex[i][2],-triangleVertex[i][1]);
					pB.set(triangleVertex[i+1][0],triangleVertex[i+1][2],-triangleVertex[i+1][1]);
					pC.set(triangleVertex[i+2][0],triangleVertex[i+2][2],-triangleVertex[i+2][1]);

					cb.subVectors( pC, pB );
					ab.subVectors( pA, pB );
					cb.cross( ab );

					cb.normalize();

					var nx = cb.x;
					var ny = cb.y;
					var nz = cb.z;

					normals[j] = nx;
					normals[j+1] = ny;
					normals[j+2] = nz;

					normals[j+3] = nx;
					normals[j+4] = ny;
					normals[j+5] = nz;

					normals[j+6] = nx;
					normals[j+7] = ny;
					normals[j+8] = nz;

					// colors
					var vx = 0;
					var vy = 222;
					var vz = 0;

					color.setRGB( vx, vy, vz );

					colors[j] = color.r;
					colors[j+1] = color.g;
					colors[j+2] = color.b;

					colors[j+3] = color.r;
					colors[j+4] = color.g;
					colors[j+5] = color.b;

					colors[j+6] = color.r;
					colors[j+7] = color.g;
					colors[j+8] = color.b;

					j+=9;
				}

				geometry.setAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );
				geometry.setAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );
				geometry.setAttribute( 'color', new THREE.BufferAttribute( colors, 3 ) );

				geometry.computeBoundingSphere();

				solidMesh = new THREE.Mesh( geometry, solidMaterial );
				scene.add( solidMesh );
			}

			// returns an array of endpoints of edges. c = zLevel, i.e. isocline value.
			// z = f(x,y). generating the level set where z = c.
			//returns (y,z,x) not (x,y,z) or (x,z,-y)
			function marchingSquares(c, resolution){
				var xStep = (xMax - xMin) / resolution;
				var yStep = (yMax - yMin) / resolution;
				var points = [];
				for (var x = xMin; x < xMax; x += xStep)
				{
					for (var y = yMin; y < yMax; y += yStep)
					{
						var z1 = f(x,y);				// bottom left corner
						var z2 = f(x+xStep, y);			// bottom right corner
						var z4 = f(x+xStep, y+yStep);	// top right corner
						var z8 = f(x, y+yStep);			// top left corner
						var n = 0;
						if (z1 > c) n += 1;
						if (z2 > c) n += 2;
						if (z4 > c) n += 4;
						if (z8 > c) n += 8;

						// calculate linear interpolation values along the given sides.
						//  to simplify, could assume each is 0.5*xStep or 0.5*yStep accordingly.
						var bottomInterp 	= (c - z1) / (z2 - z1) * xStep;
						var topInterp 		= (c - z8) / (z4 - z8) * xStep;
						var leftInterp 		= (c - z1) / (z8 - z1) * yStep;
						var rightInterp 	= (c - z2) / (z4 - z2) * yStep;

						// for a visual diagram of cases: https://en.wikipedia.org/wiki/Marching_squares
						if (n == 1 || n == 14) // lower left corner
						points.push( [y+leftInterp, 0, x], [y, 0, x+bottomInterp] );

						else if (n == 2 || n == 13) // lower right corner
						points.push( [y, 0, x+bottomInterp], [y+rightInterp, 0, x+xStep] );

						else if (n == 4 || n == 11) // upper right corner
						points.push( [y+yStep, 0, x+topInterp], [y+rightInterp, 0, x+xStep] );

						else if (n == 8 || n == 7) // upper left corner
						points.push( [y+leftInterp, 0, x], [y+yStep, 0, x+topInterp] );

						else if (n == 3 || n == 12) // horizontal
						points.push( [y+leftInterp, 0, x], [y+rightInterp, 0, x+xStep] );

						else if (n == 6 || n == 9) // vertical
						points.push( [y, 0, x+bottomInterp], [y+yStep, 0, x+topInterp] );

						else if (n == 5) // should do subcase // lower left & upper right
						points.push( [y+leftInterp, 0, x], [y, 0, x+bottomInterp], [y+yStep, 0, x+topInterp], [y+rightInterp, 0, x+xStep] );

						else if (n == 10) // should do subcase // lower right & upper left
						points.push( [y, 0, x+bottomInterp], [y+rightInterp, 0, x+xStep], [y+yStep/2, 0, x], [y+leftInterp, 0, x], [y+yStep, 0, x+topInterp] );

						else if (n == 0 || n == 15) // no line segments appear in this grid square.
						points.push();

					}
				}
				return points;

			}

			function marchingCubes(c, resolution) {
				const xStep = (xMax - xMin) / resolution
				const yStep = (yMax - yMin) / resolution
				const zStep = (zMax - zMin) / resolution
				const finalTriangles = []
				for (let x = xMin; x < xMax; x += xStep) {
					for (let y = yMin; y < yMax; y += yStep) {
						for (let z = zMin; z < zMax; z += zStep) {
							// Same order as on http://paulbourke.net/geometry/polygonise/
							const cube = new MarchingCube(x, y, z, xStep, yStep, zStep, c)
							const cubeCase = triangleTable[cube.getIndex()]
							for (let i = 0; i < cubeCase.length; i++) {
								const triangle = cubeCase[i]
								finalTriangles.push(cube.getEdgePoint(triangle[0] ));
								finalTriangles.push(cube.getEdgePoint(triangle[1] ));
								finalTriangles.push(cube.getEdgePoint(triangle[2] ));
							}
						}
					}
				}
				return finalTriangles
			}

			var triangleTable = [
				[],
				[[0, 8, 3]],
				[[0, 1, 9]],
				[[1, 8, 3], [9, 8, 1]],
				[[1, 2, 10]],
				[[0, 8, 3], [1, 2, 10]],
				[[9, 2, 10], [0, 2, 9]],
				[[2, 8, 3], [2, 10, 8], [10, 9, 8]],
				[[3, 11, 2]],
				[[0, 11, 2], [8, 11, 0]],
				[[1, 9, 0], [2, 3, 11]],
				[[1, 11, 2], [1, 9, 11], [9, 8, 11]],
				[[3, 10, 1], [11, 10, 3]],
				[[0, 10, 1], [0, 8, 10], [8, 11, 10]],
				[[3, 9, 0], [3, 11, 9], [11, 10, 9]],
				[[9, 8, 10], [10, 8, 11]],
				[[4, 7, 8]],
				[[4, 3, 0], [7, 3, 4]],
				[[0, 1, 9], [8, 4, 7]],
				[[4, 1, 9], [4, 7, 1], [7, 3, 1]],
				[[1, 2, 10], [8, 4, 7]],
				[[3, 4, 7], [3, 0, 4], [1, 2, 10]],
				[[9, 2, 10], [9, 0, 2], [8, 4, 7]],
				[[2, 10, 9], [2, 9, 7], [2, 7, 3], [7, 9, 4]],
				[[8, 4, 7], [3, 11, 2]],
				[[11, 4, 7], [11, 2, 4], [2, 0, 4]],
				[[9, 0, 1], [8, 4, 7], [2, 3, 11]],
				[[4, 7, 11], [9, 4, 11], [9, 11, 2], [9, 2, 1]],
				[[3, 10, 1], [3, 11, 10], [7, 8, 4]],
				[[1, 11, 10], [1, 4, 11], [1, 0, 4], [7, 11, 4]],
				[[4, 7, 8], [9, 0, 11], [9, 11, 10], [11, 0, 3]],
				[[4, 7, 11], [4, 11, 9], [9, 11, 10]],
				[[9, 5, 4]],
				[[9, 5, 4], [0, 8, 3]],
				[[0, 5, 4], [1, 5, 0]],
				[[8, 5, 4], [8, 3, 5], [3, 1, 5]],
				[[1, 2, 10], [9, 5, 4]],
				[[3, 0, 8], [1, 2, 10], [4, 9, 5]],
				[[5, 2, 10], [5, 4, 2], [4, 0, 2]],
				[[2, 10, 5], [3, 2, 5], [3, 5, 4], [3, 4, 8]],
				[[9, 5, 4], [2, 3, 11]],
				[[0, 11, 2], [0, 8, 11], [4, 9, 5]],
				[[0, 5, 4], [0, 1, 5], [2, 3, 11]],
				[[2, 1, 5], [2, 5, 8], [2, 8, 11], [4, 8, 5]],
				[[10, 3, 11], [10, 1, 3], [9, 5, 4]],
				[[4, 9, 5], [0, 8, 1], [8, 10, 1], [8, 11, 10]],
				[[5, 4, 0], [5, 0, 11], [5, 11, 10], [11, 0, 3]],
				[[5, 4, 8], [5, 8, 10], [10, 8, 11]],
				[[9, 7, 8], [5, 7, 9]],
				[[9, 3, 0], [9, 5, 3], [5, 7, 3]],
				[[0, 7, 8], [0, 1, 7], [1, 5, 7]],
				[[1, 5, 3], [3, 5, 7]],
				[[9, 7, 8], [9, 5, 7], [10, 1, 2]],
				[[10, 1, 2], [9, 5, 0], [5, 3, 0], [5, 7, 3]],
				[[8, 0, 2], [8, 2, 5], [8, 5, 7], [10, 5, 2]],
				[[2, 10, 5], [2, 5, 3], [3, 5, 7]],
				[[7, 9, 5], [7, 8, 9], [3, 11, 2]],
				[[9, 5, 7], [9, 7, 2], [9, 2, 0], [2, 7, 11]],
				[[2, 3, 11], [0, 1, 8], [1, 7, 8], [1, 5, 7]],
				[[11, 2, 1], [11, 1, 7], [7, 1, 5]],
				[[9, 5, 8], [8, 5, 7], [10, 1, 3], [10, 3, 11]],
				[[5, 7, 0], [5, 0, 9], [7, 11, 0], [1, 0, 10], [11, 10, 0]],
				[[11, 10, 0], [11, 0, 3], [10, 5, 0], [8, 0, 7], [5, 7, 0]],
				[[11, 10, 5], [7, 11, 5]],
				[[10, 6, 5]],
				[[0, 8, 3], [5, 10, 6]],
				[[9, 0, 1], [5, 10, 6]],
				[[1, 8, 3], [1, 9, 8], [5, 10, 6]],
				[[1, 6, 5], [2, 6, 1]],
				[[1, 6, 5], [1, 2, 6], [3, 0, 8]],
				[[9, 6, 5], [9, 0, 6], [0, 2, 6]],
				[[5, 9, 8], [5, 8, 2], [5, 2, 6], [3, 2, 8]],
				[[2, 3, 11], [10, 6, 5]],
				[[11, 0, 8], [11, 2, 0], [10, 6, 5]],
				[[0, 1, 9], [2, 3, 11], [5, 10, 6]],
				[[5, 10, 6], [1, 9, 2], [9, 11, 2], [9, 8, 11]],
				[[6, 3, 11], [6, 5, 3], [5, 1, 3]],
				[[0, 8, 11], [0, 11, 5], [0, 5, 1], [5, 11, 6]],
				[[3, 11, 6], [0, 3, 6], [0, 6, 5], [0, 5, 9]],
				[[6, 5, 9], [6, 9, 11], [11, 9, 8]],
				[[5, 10, 6], [4, 7, 8]],
				[[4, 3, 0], [4, 7, 3], [6, 5, 10]],
				[[1, 9, 0], [5, 10, 6], [8, 4, 7]],
				[[10, 6, 5], [1, 9, 7], [1, 7, 3], [7, 9, 4]],
				[[6, 1, 2], [6, 5, 1], [4, 7, 8]],
				[[1, 2, 5], [5, 2, 6], [3, 0, 4], [3, 4, 7]],
				[[8, 4, 7], [9, 0, 5], [0, 6, 5], [0, 2, 6]],
				[[7, 3, 9], [7, 9, 4], [3, 2, 9], [5, 9, 6], [2, 6, 9]],
				[[3, 11, 2], [7, 8, 4], [10, 6, 5]],
				[[5, 10, 6], [4, 7, 2], [4, 2, 0], [2, 7, 11]],
				[[0, 1, 9], [4, 7, 8], [2, 3, 11], [5, 10, 6]],
				[[9, 2, 1], [9, 11, 2], [9, 4, 11], [7, 11, 4], [5, 10, 6]],
				[[8, 4, 7], [3, 11, 5], [3, 5, 1], [5, 11, 6]],
				[[5, 1, 11], [5, 11, 6], [1, 0, 11], [7, 11, 4], [0, 4, 11]],
				[[0, 5, 9], [0, 6, 5], [0, 3, 6], [11, 6, 3], [8, 4, 7]],
				[[6, 5, 9], [6, 9, 11], [4, 7, 9], [7, 11, 9]],
				[[10, 4, 9], [6, 4, 10]],
				[[4, 10, 6], [4, 9, 10], [0, 8, 3]],
				[[10, 0, 1], [10, 6, 0], [6, 4, 0]],
				[[8, 3, 1], [8, 1, 6], [8, 6, 4], [6, 1, 10]],
				[[1, 4, 9], [1, 2, 4], [2, 6, 4]],
				[[3, 0, 8], [1, 2, 9], [2, 4, 9], [2, 6, 4]],
				[[0, 2, 4], [4, 2, 6]],
				[[8, 3, 2], [8, 2, 4], [4, 2, 6]],
				[[10, 4, 9], [10, 6, 4], [11, 2, 3]],
				[[0, 8, 2], [2, 8, 11], [4, 9, 10], [4, 10, 6]],
				[[3, 11, 2], [0, 1, 6], [0, 6, 4], [6, 1, 10]],
				[[6, 4, 1], [6, 1, 10], [4, 8, 1], [2, 1, 11], [8, 11, 1]],
				[[9, 6, 4], [9, 3, 6], [9, 1, 3], [11, 6, 3]],
				[[8, 11, 1], [8, 1, 0], [11, 6, 1], [9, 1, 4], [6, 4, 1]],
				[[3, 11, 6], [3, 6, 0], [0, 6, 4]],
				[[6, 4, 8], [11, 6, 8]],
				[[7, 10, 6], [7, 8, 10], [8, 9, 10]],
				[[0, 7, 3], [0, 10, 7], [0, 9, 10], [6, 7, 10]],
				[[10, 6, 7], [1, 10, 7], [1, 7, 8], [1, 8, 0]],
				[[10, 6, 7], [10, 7, 1], [1, 7, 3]],
				[[1, 2, 6], [1, 6, 8], [1, 8, 9], [8, 6, 7]],
				[[2, 6, 9], [2, 9, 1], [6, 7, 9], [0, 9, 3], [7, 3, 9]],
				[[7, 8, 0], [7, 0, 6], [6, 0, 2]],
				[[7, 3, 2], [6, 7, 2]],
				[[2, 3, 11], [10, 6, 8], [10, 8, 9], [8, 6, 7]],
				[[2, 0, 7], [2, 7, 11], [0, 9, 7], [6, 7, 10], [9, 10, 7]],
				[[1, 8, 0], [1, 7, 8], [1, 10, 7], [6, 7, 10], [2, 3, 11]],
				[[11, 2, 1], [11, 1, 7], [10, 6, 1], [6, 7, 1]],
				[[8, 9, 6], [8, 6, 7], [9, 1, 6], [11, 6, 3], [1, 3, 6]],
				[[0, 9, 1], [11, 6, 7]],
				[[7, 8, 0], [7, 0, 6], [3, 11, 0], [11, 6, 0]],
				[[7, 11, 6]],
				[[7, 6, 11]],
				[[3, 0, 8], [11, 7, 6]],
				[[0, 1, 9], [11, 7, 6]],
				[[8, 1, 9], [8, 3, 1], [11, 7, 6]],
				[[10, 1, 2], [6, 11, 7]],
				[[1, 2, 10], [3, 0, 8], [6, 11, 7]],
				[[2, 9, 0], [2, 10, 9], [6, 11, 7]],
				[[6, 11, 7], [2, 10, 3], [10, 8, 3], [10, 9, 8]],
				[[7, 2, 3], [6, 2, 7]],
				[[7, 0, 8], [7, 6, 0], [6, 2, 0]],
				[[2, 7, 6], [2, 3, 7], [0, 1, 9]],
				[[1, 6, 2], [1, 8, 6], [1, 9, 8], [8, 7, 6]],
				[[10, 7, 6], [10, 1, 7], [1, 3, 7]],
				[[10, 7, 6], [1, 7, 10], [1, 8, 7], [1, 0, 8]],
				[[0, 3, 7], [0, 7, 10], [0, 10, 9], [6, 10, 7]],
				[[7, 6, 10], [7, 10, 8], [8, 10, 9]],
				[[6, 8, 4], [11, 8, 6]],
				[[3, 6, 11], [3, 0, 6], [0, 4, 6]],
				[[8, 6, 11], [8, 4, 6], [9, 0, 1]],
				[[9, 4, 6], [9, 6, 3], [9, 3, 1], [11, 3, 6]],
				[[6, 8, 4], [6, 11, 8], [2, 10, 1]],
				[[1, 2, 10], [3, 0, 11], [0, 6, 11], [0, 4, 6]],
				[[4, 11, 8], [4, 6, 11], [0, 2, 9], [2, 10, 9]],
				[[10, 9, 3], [10, 3, 2], [9, 4, 3], [11, 3, 6], [4, 6, 3]],
				[[8, 2, 3], [8, 4, 2], [4, 6, 2]],
				[[0, 4, 2], [4, 6, 2]],
				[[1, 9, 0], [2, 3, 4], [2, 4, 6], [4, 3, 8]],
				[[1, 9, 4], [1, 4, 2], [2, 4, 6]],
				[[8, 1, 3], [8, 6, 1], [8, 4, 6], [6, 10, 1]],
				[[10, 1, 0], [10, 0, 6], [6, 0, 4]],
				[[4, 6, 3], [4, 3, 8], [6, 10, 3], [0, 3, 9], [10, 9, 3]],
				[[10, 9, 4], [6, 10, 4]],
				[[4, 9, 5], [7, 6, 11]],
				[[0, 8, 3], [4, 9, 5], [11, 7, 6]],
				[[5, 0, 1], [5, 4, 0], [7, 6, 11]],
				[[11, 7, 6], [8, 3, 4], [3, 5, 4], [3, 1, 5]],
				[[9, 5, 4], [10, 1, 2], [7, 6, 11]],
				[[6, 11, 7], [1, 2, 10], [0, 8, 3], [4, 9, 5]],
				[[7, 6, 11], [5, 4, 10], [4, 2, 10], [4, 0, 2]],
				[[3, 4, 8], [3, 5, 4], [3, 2, 5], [10, 5, 2], [11, 7, 6]],
				[[7, 2, 3], [7, 6, 2], [5, 4, 9]],
				[[9, 5, 4], [0, 8, 6], [0, 6, 2], [6, 8, 7]],
				[[3, 6, 2], [3, 7, 6], [1, 5, 0], [5, 4, 0]],
				[[6, 2, 8], [6, 8, 7], [2, 1, 8], [4, 8, 5], [1, 5, 8]],
				[[9, 5, 4], [10, 1, 6], [1, 7, 6], [1, 3, 7]],
				[[1, 6, 10], [1, 7, 6], [1, 0, 7], [8, 7, 0], [9, 5, 4]],
				[[4, 0, 10], [4, 10, 5], [0, 3, 10], [6, 10, 7], [3, 7, 10]],
				[[7, 6, 10], [7, 10, 8], [5, 4, 10], [4, 8, 10]],
				[[6, 9, 5], [6, 11, 9], [11, 8, 9]],
				[[3, 6, 11], [0, 6, 3], [0, 5, 6], [0, 9, 5]],
				[[0, 11, 8], [0, 5, 11], [0, 1, 5], [5, 6, 11]],
				[[6, 11, 3], [6, 3, 5], [5, 3, 1]],
				[[1, 2, 10], [9, 5, 11], [9, 11, 8], [11, 5, 6]],
				[[0, 11, 3], [0, 6, 11], [0, 9, 6], [5, 6, 9], [1, 2, 10]],
				[[11, 8, 5], [11, 5, 6], [8, 0, 5], [10, 5, 2], [0, 2, 5]],
				[[6, 11, 3], [6, 3, 5], [2, 10, 3], [10, 5, 3]],
				[[5, 8, 9], [5, 2, 8], [5, 6, 2], [3, 8, 2]],
				[[9, 5, 6], [9, 6, 0], [0, 6, 2]],
				[[1, 5, 8], [1, 8, 0], [5, 6, 8], [3, 8, 2], [6, 2, 8]],
				[[1, 5, 6], [2, 1, 6]],
				[[1, 3, 6], [1, 6, 10], [3, 8, 6], [5, 6, 9], [8, 9, 6]],
				[[10, 1, 0], [10, 0, 6], [9, 5, 0], [5, 6, 0]],
				[[0, 3, 8], [5, 6, 10]],
				[[10, 5, 6]],
				[[11, 5, 10], [7, 5, 11]],
				[[11, 5, 10], [11, 7, 5], [8, 3, 0]],
				[[5, 11, 7], [5, 10, 11], [1, 9, 0]],
				[[10, 7, 5], [10, 11, 7], [9, 8, 1], [8, 3, 1]],
				[[11, 1, 2], [11, 7, 1], [7, 5, 1]],
				[[0, 8, 3], [1, 2, 7], [1, 7, 5], [7, 2, 11]],
				[[9, 7, 5], [9, 2, 7], [9, 0, 2], [2, 11, 7]],
				[[7, 5, 2], [7, 2, 11], [5, 9, 2], [3, 2, 8], [9, 8, 2]],
				[[2, 5, 10], [2, 3, 5], [3, 7, 5]],
				[[8, 2, 0], [8, 5, 2], [8, 7, 5], [10, 2, 5]],
				[[9, 0, 1], [5, 10, 3], [5, 3, 7], [3, 10, 2]],
				[[9, 8, 2], [9, 2, 1], [8, 7, 2], [10, 2, 5], [7, 5, 2]],
				[[1, 3, 5], [3, 7, 5]],
				[[0, 8, 7], [0, 7, 1], [1, 7, 5]],
				[[9, 0, 3], [9, 3, 5], [5, 3, 7]],
				[[9, 8, 7], [5, 9, 7]],
				[[5, 8, 4], [5, 10, 8], [10, 11, 8]],
				[[5, 0, 4], [5, 11, 0], [5, 10, 11], [11, 3, 0]],
				[[0, 1, 9], [8, 4, 10], [8, 10, 11], [10, 4, 5]],
				[[10, 11, 4], [10, 4, 5], [11, 3, 4], [9, 4, 1], [3, 1, 4]],
				[[2, 5, 1], [2, 8, 5], [2, 11, 8], [4, 5, 8]],
				[[0, 4, 11], [0, 11, 3], [4, 5, 11], [2, 11, 1], [5, 1, 11]],
				[[0, 2, 5], [0, 5, 9], [2, 11, 5], [4, 5, 8], [11, 8, 5]],
				[[9, 4, 5], [2, 11, 3]],
				[[2, 5, 10], [3, 5, 2], [3, 4, 5], [3, 8, 4]],
				[[5, 10, 2], [5, 2, 4], [4, 2, 0]],
				[[3, 10, 2], [3, 5, 10], [3, 8, 5], [4, 5, 8], [0, 1, 9]],
				[[5, 10, 2], [5, 2, 4], [1, 9, 2], [9, 4, 2]],
				[[8, 4, 5], [8, 5, 3], [3, 5, 1]],
				[[0, 4, 5], [1, 0, 5]],
				[[8, 4, 5], [8, 5, 3], [9, 0, 5], [0, 3, 5]],
				[[9, 4, 5]],
				[[4, 11, 7], [4, 9, 11], [9, 10, 11]],
				[[0, 8, 3], [4, 9, 7], [9, 11, 7], [9, 10, 11]],
				[[1, 10, 11], [1, 11, 4], [1, 4, 0], [7, 4, 11]],
				[[3, 1, 4], [3, 4, 8], [1, 10, 4], [7, 4, 11], [10, 11, 4]],
				[[4, 11, 7], [9, 11, 4], [9, 2, 11], [9, 1, 2]],
				[[9, 7, 4], [9, 11, 7], [9, 1, 11], [2, 11, 1], [0, 8, 3]],
				[[11, 7, 4], [11, 4, 2], [2, 4, 0]],
				[[11, 7, 4], [11, 4, 2], [8, 3, 4], [3, 2, 4]],
				[[2, 9, 10], [2, 7, 9], [2, 3, 7], [7, 4, 9]],
				[[9, 10, 7], [9, 7, 4], [10, 2, 7], [8, 7, 0], [2, 0, 7]],
				[[3, 7, 10], [3, 10, 2], [7, 4, 10], [1, 10, 0], [4, 0, 10]],
				[[1, 10, 2], [8, 7, 4]],
				[[4, 9, 1], [4, 1, 7], [7, 1, 3]],
				[[4, 9, 1], [4, 1, 7], [0, 8, 1], [8, 7, 1]],
				[[4, 0, 3], [7, 4, 3]],
				[[4, 8, 7]],
				[[9, 10, 8], [10, 11, 8]],
				[[3, 0, 9], [3, 9, 11], [11, 9, 10]],
				[[0, 1, 10], [0, 10, 8], [8, 10, 11]],
				[[3, 1, 10], [11, 3, 10]],
				[[1, 2, 11], [1, 11, 9], [9, 11, 8]],
				[[3, 0, 9], [3, 9, 11], [1, 2, 9], [2, 11, 9]],
				[[0, 2, 11], [8, 0, 11]],
				[[3, 2, 11]],
				[[2, 3, 8], [2, 8, 10], [10, 8, 9]],
				[[9, 10, 2], [0, 9, 2]],
				[[2, 3, 8], [2, 8, 10], [0, 1, 8], [1, 10, 8]],
				[[1, 10, 2]],
				[[1, 3, 8], [9, 1, 8]],
				[[0, 9, 1]],
				[[0, 3, 8]],
				[]
			]

			/**
			 * Interpolation
			 *
			 * Interpolates to find the value of x that makes
			 * f(x) == c, assuming that a is f(x1), b is f(x2)
			 * and c is between a and b.
			 */
			function interp(x1, x2, a, b, c) {
				const t = (c - a) / (b - a)
				return x1 * (1 - t) + x2 * t
			}

			class MarchingCube {

				constructor(x, y, z, xStep, yStep, zStep, c) {
					this.x = x
					this.y = y
					this.z = z
					this.xStep = xStep
					this.yStep = yStep
					this.zStep = zStep
					this.c = c
					this.v1 = wFunc(x, y, z)
					this.v2 = wFunc(x+xStep, y, z)
					this.v4 = wFunc(x+xStep, y, z+zStep)
					this.v8 = wFunc(x, y, z+zStep)
					this.v16 = wFunc(x, y+yStep, z)
					this.v32 = wFunc(x+xStep, y+yStep, z)
					this.v64 = wFunc(x+xStep, y+yStep, z+zStep)
					this.v128 = wFunc(x, y+yStep, z+zStep)
					this.edgePoints = new Map()
				}

				/**
				 * getIndex
				 *
				 * Return the index into the 256 value lookup table
				 */
				getIndex() {
					let index = 0
					const values = [
						this.v1, this.v2, this.v4, this.v8,
						this.v16, this.v32, this.v64, this.v128
					]
					for (let i = 0; i < values.length; i++) {
						const bit = 2**i
						index += (values[i] > this.c) * bit
					}
					return index
				}

				getEdgePoint(edgeIndex) {
					if (this.edgePoints.has(edgeIndex)) {
						return this.edgePoints.get(edgeIndex)
					}
					let x, y, z
					switch (edgeIndex) {

						// See edge numbers here: http://paulbourke.net/geometry/polygonise/
						case 0:
							x = interp(this.x, this.x+this.xStep, this.v1, this.v2, this.c)
							y = this.y
							z = this.z
							break
						case 1:
							x = this.x + this.xStep
							y = this.y
							z = interp(this.z, this.z+this.zStep, this.v2, this.v4, this.c)
							break
						case 2:
							x = interp(this.x, this.x+this.xStep, this.v8, this.v4, this.c)
							y = this.y
							z = this.z + this.zStep
							break
						case 3:
							x = this.x
							y = this.y
							z = interp(this.z, this.z+this.zStep, this.v1, this.v8, this.c)
							break
						case 4:
							x = interp(this.x, this.x+this.xStep, this.v16, this.v32, this.c)
							y = this.y + this.yStep
							z = this.z
							break
						case 5:
							x = this.x + this.xStep
							y = this.y + this.yStep
							z = interp(this.z, this.z+this.zStep, this.v32, this.v64, this.c)
							break
						case 6:
							x = interp(this.x, this.x+this.xStep, this.v128, this.v64, this.c)
							y = this.y + this.yStep
							z = this.z + this.zStep
							break
						case 7:
							x = this.x
							y = this.y + this.yStep
							z = interp(this.z, this.z+this.zStep, this.v16, this.v128, this.c)
							break
						case 8:
							x = this.x
							y = interp(this.y, this.y+this.yStep, this.v1, this.v16, this.c)
							z = this.z
							break
						case 9:
							x = this.x + this.xStep
							y = interp(this.y, this.y+this.yStep, this.v2, this.v32, this.c)
							z = this.z
							break
						case 10:
							x = this.x + this.xStep
							y = interp(this.y, this.y+this.yStep, this.v4, this.v64, this.c)
							z = this.z + this.zStep
							break
						case 11:
							x = this.x
							y = interp(this.y, this.y+this.yStep, this.v8, this.v128, this.c)
							z = this.z + this.zStep
							break
						default:
							throw new Error('Edge index must be between 0 and 11')

					}
					this.edgePoints.set(edgeIndex, [x, y, z] )
					return [x, y, z]
				}

			}


		</script>

	</body>
</html>
