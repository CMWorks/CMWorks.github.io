<!DOCTYPE html>
<html lang="en">
	<head>
		<title>3D Surface</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				background-color: #cce0ff;
				color: #000;
			}
			a {
				color: #080;
			}

		</style>
		<script = src='https://cmworks.github.io/3D-Surface/build/dat.gui.min.js'></script>
		<script = src='https://cmworks.github.io/3D-Surface/build/math.min.js'></script>
		<script = src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML.js'></script>
		<script = src='https://cmworks.github.io/3D-Surface/build/three.min.js'></script>
		<script = src='https://cmworks.github.io/3D-Surface/build/OrbitControls.js'></script>
		<script = src='https://cmworks.github.io/3D-Surface/build/stats.min.js'></script>
	</head>
	<body>


		<div id="pretty"></div>
		<script>
			 var container, stats, fn;
			 var camera, scene, renderer;
			 var plane;
			 var planeMat = new THREE.MeshStandardMaterial({ vertexColors: THREE.VertexColors, side: THREE.DoubleSide });
			 var max = 0, min = 0;
			 var width = window.innerWidth-25, height = window.innerHeight-65;
			 var colorRange = 240; // 240 for blue to red
			 var texture = 0;
			 var compiledFunction;
			 var params = {
				function: "cos(x)+sin(cos(y)+x)",
				texture: changeTexture,
				color: "#000000",
				rRange: "[-5,5] Ã— [-5,5]",
				resolution: 25,
				autoUpdate: false,
				zScale: 1,
				update: update,
				coordIn: "0,0",
				tanOut: "",
				showC1C2: false,
				tangents: false,
				Clear: function(){tanPlane.visible = false;circle.visible = false;},
				n: 2,
				approximate: false,
				volume: "0",
				absVolume: "0",
				average: "0",
				upDT: function(){if (params.approximate){clearIntegralApprox(); drawIntegralApprox();}},
			};

			//grid
			var xaxis, yaxis, zaxis;
			var xMin, xMax, yMin, yMax;
			var planeWidth, planeHeight;

			// Latex output
			let options = {parenthesis: 'keep', implicit: 'hide'};
			const pretty = document.getElementById('pretty');
			let parenthesis = 'keep';
			let implicit = 'hide';
			pretty.innerHTML = '$$' + math.parse(params.function).toTex({parenthesis: parenthesis}) + '$$';

			//intersections
			//Note: b = pointZ, c = pointY, z = -f(a,b)
			var raycaster, mouse = { x : 0, y : 0 };
			var circle;

			//tangents
			var tanLineX, tanLineY, tanPlane;
			var tanFunction;
			var tanFolder;
			var showLines;
			var C1, C2;
			var r = 2;

			//Volume
			var intFolder;
			var subBoxs = [];
			var subBoxsPosMaterial, subBoxsNegMaterial;
			var volume;

			function update(){
				min = 0;
				max = 0;
				xMin = math.evaluate(params.rRange.substring(params.rRange.indexOf("[")+1,params.rRange.indexOf(",")).split("ln").join("log"))
			  xMax = math.evaluate(params.rRange.substring(params.rRange.indexOf(",")+1,params.rRange.indexOf("]")).split("ln").join("log"))
			  yMin = math.evaluate(params.rRange.substring(params.rRange.lastIndexOf("[")+1,params.rRange.lastIndexOf(",")).split("ln").join("log"))
			  yMax = math.evaluate(params.rRange.substring(params.rRange.lastIndexOf(",")+1,params.rRange.lastIndexOf("]")).split("ln").join("log"))
				planeWidth = xMax - xMin;
				planeHeight = yMax - yMin;
				scene.remove(plane);
				plane = new THREE.Mesh( new THREE.PlaneGeometry(planeWidth,planeHeight,params.resolution,params.resolution), planeMat );
				plane.rotation.x = (-Math.PI/2);
				scene.add(plane);
				for (var i = 0; i < plane.geometry.faces.length; i++) {
					plane.geometry.faces[i].vertexColors[0] = new THREE.Color( 0x000000 );
					plane.geometry.faces[i].vertexColors[1] = new THREE.Color( 0x000000 );
					plane.geometry.faces[i].vertexColors[2] = new THREE.Color( 0x000000 );
				}
				tanPlane.visible = false;circle.visible = false;
				let fun = params.function.split("ln").join("log");
				compiledFunction = math.parse(fun);
				updatePlane();
				CLineHide();
				clearIntegralApprox();
				showLines.__checkbox.checked = false;
				showLines.setValue(false);
				if (params.approximate) {
					drawIntegralApprox();
				}
			}

			function changeTexture(){
				texture+=1;
				if (texture>3) {
					texture = 0;
				}
				colorPlane();
			}

			 function f(a,b){
				 try {
					 return compiledFunction.evaluate({ x: a, y: b })
				 } catch (e) {
					return NaN;
				 }
			 }

			 function calculateTan(a,b){
				 c = compiledFunction.evaluate({x: a, y: b});
				 let dx = math.derivative(compiledFunction, "x").evaluate({x: a, y: b});
				 let dy = math.derivative(compiledFunction, "y").evaluate({x: a, y: b});
				 let cc = math.round(c-dx*a-dy*b,r);
				 tanFunction = math.format(math.simplify(math.parse(math.round(dx,r)+"*x+"+math.round(dy,r)+"*y+"+cc), {}, {exactFractions: false}));
				 tanFunction = tanFunction.split(" ").join("");
				 tanFunction = tanFunction.split("+-").join("-");
				 tanFunction = tanFunction.split("-+").join("-");
				 //tanFunction = math.format(math.simplify(math.parse(tanFunction)));
				 return [tanFunction, new THREE.Vector3(a,c,b)];
			 }

			 function CLine(a,b){
				 let res = 50, points = [];
				 scene.remove(C1);scene.remove(C2);
				 var material = new THREE.LineBasicMaterial( { color: 0x0000ff } );
				 for (var i = -params.size/2; i <= params.size/2; i+=1/res) {
					points.push( new THREE.Vector3(i,compiledFunction.evaluate({ x: i, y: b }), b) );
				 }
				 var geometry = new THREE.BufferGeometry().setFromPoints( points );

				 C1 = new THREE.Line( geometry, material );

				 points = [];
				 for (var i = -params.size/2; i <= params.size/2; i+=1/res) {
				 	points.push( new THREE.Vector3(a,compiledFunction.evaluate({ x: a, y: i }), i) );
				 }
				 geometry = new THREE.BufferGeometry().setFromPoints( points );

				 C2 = new THREE.Line( geometry, material );
				 C1.visible = plane.material.wireframe; C2.visible = plane.material.wireframe;
				 scene.add(C1);scene.add(C2);
			 }

			 function CLineHide(){
				 scene.remove(C1);scene.remove(C2);
				var material = new THREE.LineBasicMaterial( { color: 0x0000ff } );
 				var points = [];
 				points.push( new THREE.Vector3( 0, 0, 0 ) );
 				points.push( new THREE.Vector3( 0, 0, 0 ) );
 				points.push( new THREE.Vector3( 0, 0, 0 ) );
 				var geometry = new THREE.BufferGeometry().setFromPoints( points );
 				C1 = new THREE.Line( geometry, material );C2 = new THREE.Line( geometry, material );
 				C1.visible = false; C2.visible = false;
			 }

			 /**
				* Re-maps a number from one range to another.
				* @method map
				* @param  {Number} value  the incoming value to be converted
				* @param  {Number} start1 lower bound of the value's current range
				* @param  {Number} stop1  upper bound of the value's current range
				* @param  {Number} start2 lower bound of the value's target range
				* @param  {Number} stop2  upper bound of the value's target range
				* @param  {Boolean} [withinBounds] constrain the value to the newly mapped range
				* @return {Number}        remapped number
				*
				*/
			function map(n, start1, stop1, start2, stop2){
				return (n - start1) / (stop1 - start1) * (stop2 - start2) + start2;
			}

			function hslToRgb(h, s, l){
				var r, g, b;

				if(s == 0){
						r = g = b = l; // achromatic
				}else{
						var hue2rgb = function hue2rgb(p, q, t){
								if(t < 0) t += 1;
								if(t > 1) t -= 1;
								if(t < 1/6) return p + (q - p) * 6 * t;
								if(t < 1/2) return q;
								if(t < 2/3) return p + (q - p) * (2/3 - t) * 6;
								return p;
						}

						var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
						var p = 2 * l - q;
						r = hue2rgb(p, q, h + 1/3);
						g = hue2rgb(p, q, h);
						b = hue2rgb(p, q, h - 1/3);
				}

				return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
			}

			function updatePlane(){
				// total vertices for a resolution of n is n^2+2*n+1
				//sets vertices to points based on bounded range R
				var n = 0;
				var dx = planeWidth/params.resolution;
				var dy = planeHeight/params.resolution;
				for (var y = yMin; y <= yMax+dy/2; y+=dy) {	//offseted by dy to acount for rounding error
					for (var x = xMin; x <= xMax+dx/2; x+=dx) {
						if (n < params.resolution*params.resolution+2*params.resolution+1) {
							plane.geometry.vertices[n].x = x;
							plane.geometry.vertices[n].y = y;
							n++;
						}else {
							break;
						}
					}
				}

				//sets vertices to actual values
				for (var i = 0; i < plane.geometry.vertices.length; i++) {
					let newZ = f(plane.geometry.vertices[i].x, plane.geometry.vertices[i].y)*params.zScale;
					plane.geometry.vertices[i].z = newZ;
					if (isFinite(newZ)) {
						if (newZ > max) {
							max = newZ;
						}if (newZ < min) {
							min = newZ;
						}
					}
				}
				colorPlane();
				plane.geometry.verticesNeedUpdate=true;
			}

			function colorPlane(){
				for (var i = 0; i < plane.geometry.faces.length; i++) {
					plane.geometry.faces[i].vertexColors[0].setHex(0x000000)
					plane.geometry.faces[i].vertexColors[1].setHex(0x000000)
					plane.geometry.faces[i].vertexColors[2].setHex(0x000000)
				}
				for (var i = 0; i < plane.geometry.faces.length; i++) {
					var a = plane.geometry.vertices[plane.geometry.faces[i].a].z;
					var b = plane.geometry.vertices[plane.geometry.faces[i].b].z;
					var c = plane.geometry.vertices[plane.geometry.faces[i].c].z;
					if (texture == 0) { // colored lines
						plane.geometry.faces[i].vertexColors[0].add(new THREE.Color(params.color));
						plane.geometry.faces[i].vertexColors[1].add(new THREE.Color());
						plane.geometry.faces[i].vertexColors[2].add(new THREE.Color(params.color));
						var ca = colorRange-Math.round(map(a, min, max, 0, colorRange));
						var cb = colorRange-Math.round(map(b, min, max, 0, colorRange));
						var cc = colorRange-Math.round(map(c, min, max, 0, colorRange));
						if (isFinite(ca)) {
							plane.geometry.faces[i].vertexColors[0].add(new THREE.Color("hsl("+ca+",75%,40%)"));
						}if (isFinite(cb)) {
							plane.geometry.faces[i].vertexColors[1].add(new THREE.Color("hsl("+cb+",75%,40%)"));
						}if (isFinite(cc)) {
							plane.geometry.faces[i].vertexColors[2].add(new THREE.Color("hsl("+cc+",75%,40%)"));
						}
					}else if(texture == 1){ // blue map
						var cb = Math.round(map(b, min, max, 00, 255));
						var cc = Math.round(map(c, min, max, 0, 255));
						if (isFinite(ca)) {
							plane.geometry.faces[i].vertexColors[0].setHex(0x000000);
						}if (isFinite(cb)) {
							plane.geometry.faces[i].vertexColors[1].setHex(cb);
						}if (isFinite(cc)) {
							plane.geometry.faces[i].vertexColors[2].setHex(cc);
						}
					}else if(texture == 2){ // white lines
						var ca = colorRange-Math.round(map(a, min, max, 0, colorRange));
						var cb = colorRange-Math.round(map(b, min, max, 0, colorRange));
						var cc = colorRange-Math.round(map(c, min, max, 0, colorRange));
						var col = hslToRgb(ca, .75, .4);
						if (isFinite(ca)) {
							plane.geometry.faces[i].vertexColors[0].setRGB(col[0],col[1],col[2]);
						}if (isFinite(cb)) {
							col = hslToRgb(cb, .75, .4);
							plane.geometry.faces[i].vertexColors[1].setHSL(col[0],col[1],col[2]);
						}if (isFinite(cc)) {
							col = hslToRgb(cc, .75, .4);
							plane.geometry.faces[i].vertexColors[2].setHSL(col[0],col[1],col[2]);
						}
					}else if (texture == 3) { // green layerd map
						var ca = Math.round(map(a, min, max, 1000000, colorRange));
						var cb = Math.round(map(b, min, max, 1000000, colorRange));
						var cc = Math.round(map(c, min, max, 1000000, colorRange));
						//console.log(ca+", "+cb+", "+cc);
						if (isFinite(ca)) {
							plane.geometry.faces[i].vertexColors[0].setHex(ca);
						}if (isFinite(cb)) {
							plane.geometry.faces[i].vertexColors[1].setHex(cb);
						}if (isFinite(cc)) {
							plane.geometry.faces[i].vertexColors[2].setHex(cc);
						}
					}
				}
				plane.geometry.colorsNeedUpdate = true;
			}

			init();
			animate();

			function init() {

				container = document.createElement( 'div' );
				document.body.appendChild( container );

				// scene

				scene = new THREE.Scene();
				scene.background = new THREE.Color( 0xcce0ff );

				// camera

				camera = new THREE.PerspectiveCamera( 30, width / height, 1, 10000 );

				// lights

				scene.add( new THREE.AmbientLight( 0x666666 ) );

				var light = new THREE.DirectionalLight( 0x666666, 1 );
				light.position.set( 50, 200, 100 );
				light.position.multiplyScalar( 1.3 );

				light.castShadow = true;

				light.shadow.mapSize.width = 1024;
				light.shadow.mapSize.height = 1024;

				var d = 300;

				light.shadow.camera.left = - d;
				light.shadow.camera.right = d;
				light.shadow.camera.top = d;
				light.shadow.camera.bottom = - d;

				light.shadow.camera.far = 1000;

				scene.add( light );


				// adds plane
				plane = new THREE.Mesh( new THREE.PlaneGeometry(10,10,10,10), planeMat );
				plane.rotation.x = (-Math.PI/2);
				scene.add(plane);
				for (var i = 0; i < plane.geometry.faces.length; i++) {
					plane.geometry.faces[i].vertexColors[0] = new THREE.Color( 0x000000 );
					plane.geometry.faces[i].vertexColors[1] = new THREE.Color( 0x000000 );
					plane.geometry.faces[i].vertexColors[2] = new THREE.Color( 0x000000 );
				}
				camera.position.set( 10, 5, 15 );
				camera.lookAt(0,0,10);

				//adds tangent plane
				tanPlane = new THREE.Mesh( new THREE.PlaneGeometry(10,10), planeMat );
				tanPlane.visible = false;
				tanPlane.rotateX(math.pi/2);
				scene.add(tanPlane);

				//adds C1 and C2
				var material = new THREE.LineBasicMaterial( { color: 0x0000ff } );
				var points = [];
				points.push( new THREE.Vector3( 0, 0, 0 ) );
				points.push( new THREE.Vector3( 0, 0, 0 ) );
				points.push( new THREE.Vector3( 0, 0, 0 ) );
				var geometry = new THREE.BufferGeometry().setFromPoints( points );
				C1 = new THREE.Line( geometry, material );C2 = new THREE.Line( geometry, material );
				C1.visible = false; C2.visible = false;

				//grid
				var s = 5;
				xaxis = new THREE.Mesh(new THREE.BoxGeometry( s,.05,.05 ), new THREE.MeshBasicMaterial( {color: 0xff0000} ));
				zaxis = new THREE.Mesh(new THREE.BoxGeometry( .05,s,.05 ), new THREE.MeshBasicMaterial( {color: 0x0000ff} ));
				yaxis = new THREE.Mesh(new THREE.BoxGeometry( .05,.05,s ), new THREE.MeshBasicMaterial( {color: 0x00ff00} ));
				xaxis.geometry.translate(s/2,0,0)
				zaxis.geometry.translate(0,s/2,0)
				yaxis.geometry.translate(0,0,-s/2)
				scene.add(xaxis);
				scene.add(yaxis);
				scene.add(zaxis);

				//subBoxes material
				subBoxsPosMaterial = new THREE.MeshPhongMaterial( {color: 0x00ff00, side: THREE.DoubleSide, transparent: true, opacity: .5} );
				subBoxsNegMaterial = new THREE.MeshPhongMaterial( {color: 0x00fff0, side: THREE.DoubleSide, transparent: true, opacity: .5} );

				// renderer

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( width, height );

				container.appendChild( renderer.domElement );

				renderer.outputEncoding = THREE.sRGBEncoding;

				renderer.shadowMap.enabled = true;

				// intersections
				raycaster = new THREE.Raycaster();
    		renderer.domElement.addEventListener( 'mousemove', updateMouse, false );
				circle = new THREE.Mesh(new THREE.SphereGeometry( .1, 32, 32 ), new THREE.MeshBasicMaterial( {color: 0xffff00} ));
				circle.visible = false;
				scene.add(circle);

				// controls
				var controls = new THREE.OrbitControls( camera, renderer.domElement );
				//controls.maxPolarAngle = Math.PI * 0.5;
				controls.minDistance = 1;
				controls.maxDistance = 5000;
				// call this only in static scenes (i.e., if there is no animation loop)
				controls.addEventListener( 'change', render );

				// performance monitor

				stats = new Stats();
				container.appendChild( stats.dom );

				//event listener
				window.addEventListener( 'resize', onWindowResize, false );

				// gui
				var gui = new dat.GUI();
				fn = gui.add( params, 'function' ).name("f(x,y)=").onFinishChange(function(){
					update();
				});
				gui.add( params, 'texture' );
				gui.addColor(params, 'color').onChange(function(value) {
					colorPlane();
				});
				gui.add( params, 'rRange' ).name("R = ").onFinishChange(function(){
			    update();
			  });
				gui.add( params, 'resolution' ).min(1).max(1000).step(1);
				gui.add( params, 'zScale' ).min(0).max(2).name("Z-Scale");
				gui.add( params, 'update' );

				//tanFolder
				tanFolder = gui.addFolder("Tangent");
				coordIn = tanFolder.add(params, "coordIn").name("Coordinate x,y").onFinishChange(function(){
					drawTangents();
				});
				tanOut = tanFolder.add(params, "tanOut").name("z=");
				document.getElementsByTagName("input")[6].disabled = true;
				showLines = tanFolder.add( params, 'showC1C2').name("Show C1 & C2").onFinishChange(function(){
					plane.material.wireframe = params.showC1C2;
					C1.visible = plane.material.wireframe;
 				 	C2.visible = plane.material.wireframe;
				});
				tanFolder.add( params, 'tangents').name("Auto Display");
				tanFolder.add(params, "Clear");

				//Integral folder
				intFolder = gui.addFolder("Integral");
				intFolder.add(params, "n").min(2).max(100).step(1);
				intFolder.add(params, "approximate").name("Approx Volume").onFinishChange(function(){
					if (params.approximate) {
						drawIntegralApprox();
					}else {
						clearIntegralApprox();
					}
				});
				intFolder.add(params, "volume").name("Volume: ");
				document.getElementsByTagName("input")[11].disabled = true;
				intFolder.add(params, "absVolume").name("Abs Volume: ");
				document.getElementsByTagName("input")[12].disabled = true;
				intFolder.add(params, "average").name("Average Value: ");
				document.getElementsByTagName("input")[13].disabled = true;

				intFolder.add(params,"upDT").name("Update Volume");

				update();
			}

			function onWindowResize() {

				camera.aspect = (window.innerWidth-25) / (window.innerHeight-65);
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth-25, window.innerHeight-65 );

			}

			function animate() {

				requestAnimationFrame( animate );
				var time = Date.now();
				render();
				stats.update();
			}

			function render() {
				print();
				if (params.tangents) {
					raycast();
				}
				renderer.render( scene, camera );
			}

			function print () {
				let node = null
				let fun = params.function;
				try {
					// parse the expression and simplifies it
					// node = math.simplify(math.parse(fun));
					// fn.setValue(node.toString());

					//regular parse
					node = math.parse(fun);
				}
				catch (err) {}

				try {
					// export the expression to LaTeX
					node = math.parse("f(x,y)=="+node.toString());
					const latex = node ? node.toTex({parenthesis: parenthesis, implicit: implicit}) : ''

					// display and re-render the expression
					const elem = MathJax.Hub.getAllJax('pretty')[0]
					MathJax.Hub.Queue(['Text', elem, latex])
				}
				catch (err) {}
			}

			function updateMouse( e ){
				mouse.x = ( e.clientX / (window.innerWidth-25) ) * 2 - 1 - (11/window.innerWidth);
				mouse.y = - ( e.clientY / (window.innerHeight-65) ) * 2 + 1 + (110/window.innerHeight);
			}

			function raycast ( ) {
				//1. sets the mouse position with a coordinate system where the center
				//   of the screen is the origin


				//2. set the picking ray from the camera position and mouse coordinates
				raycaster.setFromCamera( mouse, camera );

				//3. compute intersections
				var intersects = raycaster.intersectObjects( [plane] );
				if (intersects.length > 0) {
					let a = intersects[0].point.x, b = -intersects[0].point.z, c = intersects[0].point.y;
					let v = calculateTan(a,b);
					circle.position.set(v[1].x,v[1].y,-v[1].z);
					tanOut.setValue(v[0]);
					coordIn.setValue(math.round(a,r)+","+math.round(b,r))

					//updates tangent plane
					tanPlane.geometry.vertices[0].x = a-1;
					tanPlane.geometry.vertices[0].y = -b+1;
					tanPlane.geometry.vertices[0].z = -math.parse(tanFunction).evaluate({ x: a-1, y: b-1 });

					tanPlane.geometry.vertices[1].x = a+1;
					tanPlane.geometry.vertices[1].y = -b+1;
					tanPlane.geometry.vertices[1].z = -math.parse(tanFunction).evaluate({ x: a+1, y: b-1 });

					tanPlane.geometry.vertices[3].x = a+1;
					tanPlane.geometry.vertices[3].y = -b-1;
					tanPlane.geometry.vertices[3].z = -math.parse(tanFunction).evaluate({ x: a+1, y: b+1 });

					tanPlane.geometry.vertices[2].x = a-1;
					tanPlane.geometry.vertices[2].y = -b-1;
					tanPlane.geometry.vertices[2].z = -math.parse(tanFunction).evaluate({ x: a-1, y: b+1 });

					tanPlane.geometry.verticesNeedUpdate=true;
					// console.log(f(intersects[ i ].point.x, intersects[ i ].point.y));
					/*
					An intersection has the following properties :
					- object : intersected object (THREE.Mesh)
					- distance : distance from camera to intersection (number)
					- face : intersected face (THREE.Face3)
					- faceIndex : intersected face index (number)
					- point : intersection point (THREE.Vector3)
					- uv : intersection point in the object's UV coordinates (THREE.Vector2)
					*/
					tanPlane.visible = true;
					circle.visible = true;

					//updates tangent curves
					CLine(a, b);
				}

			}

			function drawTangents(a,b){
				tanPlane.visible = true;
				circle.visible = true;
				var a = math.parse(params.coordIn.substr(0,params.coordIn.indexOf(',')).split("ln").join("log")).evaluate();
				var b = math.parse(params.coordIn.substr(params.coordIn.indexOf(',')+1).split("ln").join("log")).evaluate();
				var v = calculateTan(a,b);
				circle.position.set(v[1].x,v[1].y,-v[1].z);
				tanOut.setValue(v[0]);

				//updates tangent plane
				tanPlane.geometry.vertices[0].x = a-1;
				tanPlane.geometry.vertices[0].y = -b+1;
				tanPlane.geometry.vertices[0].z = -math.parse(tanFunction).evaluate({ x: a-1, y: b-1 });

				tanPlane.geometry.vertices[1].x = a+1;
				tanPlane.geometry.vertices[1].y = -b+1;
				tanPlane.geometry.vertices[1].z = -math.parse(tanFunction).evaluate({ x: a+1, y: b-1 });

				tanPlane.geometry.vertices[3].x = a+1;
				tanPlane.geometry.vertices[3].y = -b-1;
				tanPlane.geometry.vertices[3].z = -math.parse(tanFunction).evaluate({ x: a+1, y: b+1 });

				tanPlane.geometry.vertices[2].x = a-1;
				tanPlane.geometry.vertices[2].y = -b-1;
				tanPlane.geometry.vertices[2].z = -math.parse(tanFunction).evaluate({ x: a-1, y: b+1 });

				tanPlane.geometry.verticesNeedUpdate=true;

				//updates tangent curves
				CLine(a, b);
			}

			function drawIntegralApprox(){
				subBoxs = [];
				dx = planeWidth/params.n;
				dy = planeHeight/params.n;
				//left point approx
				volume = 0;
				absVol = 0;
				i = 0;
				for (var y = yMin; y < yMax; y+=dy) {
					for (var x = xMin; x < xMax; x+=dx) {
						//point (x,z,-y)
						var z = f(x,y)*params.zScale;
						if (z >=0 ) {
							subBoxs[i] = new THREE.Mesh(new THREE.BoxGeometry( dx, z ,dy ), subBoxsPosMaterial);
						}else {
							subBoxs[i] = new THREE.Mesh(new THREE.BoxGeometry( dx, z ,dy ), subBoxsNegMaterial);
						}
						subBoxs[i].translateX(x);
						subBoxs[i].translateZ(-y);
						subBoxs[i].translateY(z/2);
						volume += dx*dy*z;
						absVol += Math.abs(dx*dy*z);
						i++;
					}
				}
				params.volume = ""+math.round(volume,r+2);
				params.absVolume = ""+math.round(absVol,r+2);
				params.average = ""+math.round(volume/(planeWidth*planeHeight),r+2)
				intFolder.updateDisplay();
				planeMat.visible = false;
				for (var i = 0; i < subBoxs.length; i++) {
					scene.add(subBoxs[i]);
				}
			}

			function clearIntegralApprox(){
				planeMat.visible = true;
				for (var i = 0; i < subBoxs.length; i++) {
					scene.remove(subBoxs[i]);
				}

			}

		</script>

	</body>
</html>
