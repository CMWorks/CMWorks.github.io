<!DOCTYPE html>
<html lang="en">
	<head>
		<title>3D Surface</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
		<style>
			body {
				background-color: #cce0ff;
				color: #000;
			}
			a {
				color: #080;
			}

		</style>
		<script = src='https://cmworks.github.io/3D-Surface/build/dat.gui.min.js'></script>
		<script = src='https://cmworks.github.io/3D-Surface/build/math.min.js'></script>
		<script = src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML.js'></script>
		<script = src='https://cmworks.github.io/3D-Surface/build/three.min.js'></script>
		<script = src='https://cmworks.github.io/3D-Surface/build/OrbitControls.js'></script>
		<script = src='https://cmworks.github.io/3D-Surface/build/stats.min.js'></script>
	</head>
	<body>


		<div id="pretty"></div>
		<script>
			 var container, stats, fn;
			 var camera, scene, renderer;
			 var plane;
			 var planeMat = new THREE.MeshStandardMaterial({ vertexColors: THREE.VertexColors, side: THREE.DoubleSide });
			 var max = 0, min = 0;
			 var width = window.innerWidth-25, height = window.innerHeight-65;
			 var colorRange = 240; // 240 for blue to red
			 var texture = 0;
			 var compiledFunction;
			 var params = {
				function: "x",
				texture: changeTexture,
				color: "#000000",
				size: 5,
				resolution: 10,
				autoUpdate: false,
				zScale: 1,
				update: update
			};

			function update(){
				min = 0;
				max = 0;
				scene.remove(plane);
				plane = new THREE.Mesh( new THREE.PlaneGeometry(params.size,params.size,params.resolution,params.resolution), planeMat );
				plane.rotation.x = (-Math.PI/2);
				scene.add(plane);
				for (var i = 0; i < plane.geometry.faces.length; i++) {
					plane.geometry.faces[i].vertexColors[0] = new THREE.Color( 0x000000 );
					plane.geometry.faces[i].vertexColors[1] = new THREE.Color( 0x000000 );
					plane.geometry.faces[i].vertexColors[2] = new THREE.Color( 0x000000 );
				}
				let fun = params.function;
				compiledFunction = math.parse(fun).compile();
				updatePlane();
			}

			function changeTexture(){
				texture+=1;
				if (texture>3) {
					texture = 0;
				}
				colorPlane();
			}

			 function f(a,b){
				 try {
					 return compiledFunction.evaluate({ x: a, y: b })
				 } catch (e) {
					return NaN;
				 }
			 }
			 /**
				* Re-maps a number from one range to another.
				* @method map
				* @param  {Number} value  the incoming value to be converted
				* @param  {Number} start1 lower bound of the value's current range
				* @param  {Number} stop1  upper bound of the value's current range
				* @param  {Number} start2 lower bound of the value's target range
				* @param  {Number} stop2  upper bound of the value's target range
				* @param  {Boolean} [withinBounds] constrain the value to the newly mapped range
				* @return {Number}        remapped number
				*
				*/
			function map(n, start1, stop1, start2, stop2){
				return (n - start1) / (stop1 - start1) * (stop2 - start2) + start2;
			}

			function hslToRgb(h, s, l){
				var r, g, b;

				if(s == 0){
						r = g = b = l; // achromatic
				}else{
						var hue2rgb = function hue2rgb(p, q, t){
								if(t < 0) t += 1;
								if(t > 1) t -= 1;
								if(t < 1/6) return p + (q - p) * 6 * t;
								if(t < 1/2) return q;
								if(t < 2/3) return p + (q - p) * (2/3 - t) * 6;
								return p;
						}

						var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
						var p = 2 * l - q;
						r = hue2rgb(p, q, h + 1/3);
						g = hue2rgb(p, q, h);
						b = hue2rgb(p, q, h - 1/3);
				}

				return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
			}

			function updatePlane(){
				for (var i = 0; i < plane.geometry.vertices.length; i++) {
					let newZ = f(plane.geometry.vertices[i].x, plane.geometry.vertices[i].y)*params.zScale;
					plane.geometry.vertices[i].z = newZ;
					if (isFinite(newZ)) {
						if (newZ > max) {
							max = newZ;
						}if (newZ < min) {
							min = newZ;
						}
					}
				}
				colorPlane();
				plane.geometry.verticesNeedUpdate=true;
			}

			function colorPlane(){
				for (var i = 0; i < plane.geometry.faces.length; i++) {
					plane.geometry.faces[i].vertexColors[0].setHex(0x000000)
					plane.geometry.faces[i].vertexColors[1].setHex(0x000000)
					plane.geometry.faces[i].vertexColors[2].setHex(0x000000)
				}
				for (var i = 0; i < plane.geometry.faces.length; i++) {
					var a = plane.geometry.vertices[plane.geometry.faces[i].a].z;
					var b = plane.geometry.vertices[plane.geometry.faces[i].b].z;
					var c = plane.geometry.vertices[plane.geometry.faces[i].c].z;
					if (texture == 0) { // colored lines
						plane.geometry.faces[i].vertexColors[0].add(new THREE.Color(params.color));
						plane.geometry.faces[i].vertexColors[1].add(new THREE.Color());
						plane.geometry.faces[i].vertexColors[2].add(new THREE.Color(params.color));
						var ca = colorRange-Math.round(map(a, min, max, 0, colorRange));
						var cb = colorRange-Math.round(map(b, min, max, 0, colorRange));
						var cc = colorRange-Math.round(map(c, min, max, 0, colorRange));
						if (isFinite(ca)) {
							plane.geometry.faces[i].vertexColors[0].add(new THREE.Color("hsl("+ca+",75%,40%)"));
						}if (isFinite(cb)) {
							plane.geometry.faces[i].vertexColors[1].add(new THREE.Color("hsl("+cb+",75%,40%)"));
						}if (isFinite(cc)) {
							plane.geometry.faces[i].vertexColors[2].add(new THREE.Color("hsl("+cc+",75%,40%)"));
						}
					}else if(texture == 1){ // blue map
						var cb = Math.round(map(b, min, max, 00, 255));
						var cc = Math.round(map(c, min, max, 0, 255));
						if (isFinite(ca)) {
							plane.geometry.faces[i].vertexColors[0].setHex(0x000000);
						}if (isFinite(cb)) {
							plane.geometry.faces[i].vertexColors[1].setHex(cb);
						}if (isFinite(cc)) {
							plane.geometry.faces[i].vertexColors[2].setHex(cc);
						}
					}else if(texture == 2){ // white lines
						var ca = colorRange-Math.round(map(a, min, max, 0, colorRange));
						var cb = colorRange-Math.round(map(b, min, max, 0, colorRange));
						var cc = colorRange-Math.round(map(c, min, max, 0, colorRange));
						var col = hslToRgb(ca, .75, .4);
						if (isFinite(ca)) {
							plane.geometry.faces[i].vertexColors[0].setRGB(col[0],col[1],col[2]);
						}if (isFinite(cb)) {
							col = hslToRgb(cb, .75, .4);
							plane.geometry.faces[i].vertexColors[1].setHSL(col[0],col[1],col[2]);
						}if (isFinite(cc)) {
							col = hslToRgb(cc, .75, .4);
							plane.geometry.faces[i].vertexColors[2].setHSL(col[0],col[1],col[2]);
						}
					}else if (texture == 3) { // green layerd map
						var ca = Math.round(map(a, min, max, 1000000, colorRange));
						var cb = Math.round(map(b, min, max, 1000000, colorRange));
						var cc = Math.round(map(c, min, max, 1000000, colorRange));
						//console.log(ca+", "+cb+", "+cc);
						if (isFinite(ca)) {
							plane.geometry.faces[i].vertexColors[0].setHex(ca);
						}if (isFinite(cb)) {
							plane.geometry.faces[i].vertexColors[1].setHex(cb);
						}if (isFinite(cc)) {
							plane.geometry.faces[i].vertexColors[2].setHex(cc);
						}
					}
				}
				plane.geometry.colorsNeedUpdate = true;
			}


			init();
			animate();

			function init() {

				container = document.createElement( 'div' );
				document.body.appendChild( container );

				// scene

				scene = new THREE.Scene();
				scene.background = new THREE.Color( 0xcce0ff );

				// camera

				camera = new THREE.PerspectiveCamera( 30, width / height, 1, 10000 );

				// lights

				scene.add( new THREE.AmbientLight( 0x666666 ) );

				var light = new THREE.DirectionalLight( 0x666666, 1 );
				light.position.set( 50, 200, 100 );
				light.position.multiplyScalar( 1.3 );

				light.castShadow = true;

				light.shadow.mapSize.width = 1024;
				light.shadow.mapSize.height = 1024;

				var d = 300;

				light.shadow.camera.left = - d;
				light.shadow.camera.right = d;
				light.shadow.camera.top = d;
				light.shadow.camera.bottom = - d;

				light.shadow.camera.far = 1000;

				scene.add( light );

				plane = new THREE.Mesh( new THREE.PlaneGeometry(10,10,10,10), planeMat );
				plane.rotation.x = (-Math.PI/2);
				scene.add(plane);
				for (var i = 0; i < plane.geometry.faces.length; i++) {
					plane.geometry.faces[i].vertexColors[0] = new THREE.Color( 0x000000 );
					plane.geometry.faces[i].vertexColors[1] = new THREE.Color( 0x000000 );
					plane.geometry.faces[i].vertexColors[2] = new THREE.Color( 0x000000 );
				}
				camera.position.set( 10, 5, 15 );
				camera.lookAt(0,0,10);

				// renderer

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( width, height );

				container.appendChild( renderer.domElement );

				renderer.outputEncoding = THREE.sRGBEncoding;

				renderer.shadowMap.enabled = true;

				// controls
				var controls = new THREE.OrbitControls( camera, renderer.domElement );
				controls.maxPolarAngle = Math.PI * 0.5;
				controls.minDistance = 1;
				controls.maxDistance = 5000;
				// call this only in static scenes (i.e., if there is no animation loop)
				controls.addEventListener( 'change', render );

				// performance monitor

				stats = new Stats();
				container.appendChild( stats.dom );

				//

				window.addEventListener( 'resize', onWindowResize, false );

				//
				var gui = new dat.GUI();
				fn = gui.add( params, 'function' ).name("f(x,y)=").onFinishChange(function(){
					update();
				});
				gui.add( params, 'texture' );
				gui.addColor(params, 'color').onChange(function(value) {
					colorPlane();
				});
				gui.add( params, 'size' ).min(0).max(15).step(1);
				gui.add( params, 'resolution' ).min(1).max(1000).step(1);
				gui.add( params, 'zScale' ).min(0).max(2).name("Z-Scale");
				gui.add( params, 'update' );
				update();
			}

			function onWindowResize() {

				camera.aspect = (window.innerWidth-25) / (window.innerHeight-65);
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth-25, window.innerHeight-65 );

			}

			function animate() {

				requestAnimationFrame( animate );

				var time = Date.now();
				render();
				stats.update();
			}

			function render() {
				renderer.render( scene, camera );
				print();
			}

			let options = {parenthesis: 'keep', implicit: 'hide'}
			const pretty = document.getElementById('pretty')
			let parenthesis = 'keep'
			let implicit = 'hide'

			// initialize with an example expression
			pretty.innerHTML = '$$' + math.parse(params.function).toTex({parenthesis: parenthesis}) + '$$'

			function print () {
				let node = null
				let fun = params.function;
				try {
					// parse the expression
					node = math.simplify(math.parse(fun));
					fn.setValue(node.toString());
				}
				catch (err) {}

				try {
					// export the expression to LaTeX
					node = math.parse("f(x,y)=="+node.toString());
					const latex = node ? node.toTex({parenthesis: parenthesis, implicit: implicit}) : ''

					// display and re-render the expression
					const elem = MathJax.Hub.getAllJax('pretty')[0]
					MathJax.Hub.Queue(['Text', elem, latex])
				}
				catch (err) {}
			}

		</script>

	</body>
</html>
